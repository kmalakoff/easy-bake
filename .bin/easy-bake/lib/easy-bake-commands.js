// Generated by CoffeeScript 1.3.3
(function() {
  var eb, fs, globber, path, spawn, timeLog, uglifyjs, wrench, _;

  if (!eb) {
    eb = {};
  }

  if (!this.eb) {
    this.eb = {};
  }

  eb.utils = require('./easy-bake-utils');

  eb.command = this.eb.command = typeof exports !== 'undefined' ? exports : {};

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  eb.command.Queue = (function() {

    function Queue() {
      this.commands_queue = [];
      this.is_running = false;
      this.errors = [];
    }

    Queue.prototype.commands = function() {
      return this.commands_queue;
    };

    Queue.prototype.errorCount = function() {
      return this.errors.length;
    };

    Queue.prototype.push = function(command) {
      return this.commands_queue.push(command);
    };

    Queue.prototype.run = function(run_options, callback) {
      var current_index, done, next,
        _this = this;
      if (this.is_running) {
        throw 'queue is already running';
      }
      this.is_running = true;
      this.errors = [];
      current_index = 0;
      done = function() {
        _this.is_running = false;
        return typeof callback === "function" ? callback(_this) : void 0;
      };
      next = function(code, task) {
        if ((code !== 0) && (arguments.length !== 0)) {
          _this.errors.push({
            code: code,
            task: task
          });
        }
        if (++current_index < _this.commands_queue.length) {
          return _this.commands_queue[current_index].run(run_options, next, _this);
        } else {
          return done();
        }
      };
      if (this.commands_queue.length) {
        return this.commands_queue[current_index].run(run_options, next, this);
      } else {
        return done();
      }
    };

    return Queue;

  })();

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  _ = require('underscore');

  wrench = require('wrench');

  uglifyjs = require('uglify-js');

  globber = require('glob-whatev');

  eb.command.RunQueue = (function() {

    function RunQueue(run_queue, name) {
      this.run_queue = run_queue;
      this.name = name;
      if (!this.run_queue) {
        this.run_queue = new eb.command.Queue();
      }
    }

    RunQueue.prototype.queue = function() {
      return this.run_queue;
    };

    RunQueue.prototype.run = function(options, callback) {
      if (options == null) {
        options = {};
      }
      if (options.verbose) {
        console.log("running queue: " + this.name);
      }
      return this.run_queue.run(options, function(queue) {
        return typeof callback === "function" ? callback(queue.errorCount(), this) : void 0;
      });
    };

    return RunQueue;

  })();

  eb.command.RunCommand = (function() {

    function RunCommand(command, args, command_options) {
      this.command = command;
      this.args = args != null ? args : [];
      this.command_options = command_options != null ? command_options : {};
    }

    RunCommand.prototype.run = function(options, callback) {
      var spawned;
      if (options == null) {
        options = {};
      }
      if (options.preview || options.verbose) {
        console.log("" + (this.command_options.cwd ? this.command_options.cwd + ': ' : '') + this.command + " " + (eb.utils.relativeArguments(this.args, this.command_options.cwd).join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      spawned = spawn(this.command, this.args, eb.utils.extractCWD(this.command_options));
      spawned.stderr.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      spawned.stdout.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      return spawned.on('exit', function(code) {
        this.exit_code = code;
        if (code === 0) {
          if (!options.silent) {
            timeLog("command succeeded " + this.command + " " + (eb.utils.relativeArguments(this.args, this.command_options.cwd).join(' ')));
          }
        } else {
          timeLog("command failed " + this.command + " " + (eb.utils.relativeArguments(this.args, this.command_options.cwd).join(' ')) + " (exit code: " + code + ")");
        }
        return typeof callback === "function" ? callback(code, this) : void 0;
      });
    };

    return RunCommand;

  })();

  eb.command.Remove = (function() {

    function Remove(args, command_options) {
      if (args == null) {
        args = [];
      }
      this.command_options = command_options != null ? command_options : {};
      this.args = eb.utils.resolveArguments(args, this.command_options.cwd);
    }

    Remove.prototype.target = function() {
      return this.args[this.args.length - 1];
    };

    Remove.prototype.run = function(options, callback) {
      var parent_dir;
      if (options == null) {
        options = {};
      }
      if (!path.existsSync(this.target())) {
        if (typeof callback === "function") {
          callback(0, this);
        }
        return;
      }
      if (options.preview || options.verbose) {
        console.log("rm " + (eb.utils.relativeArguments(this.args, this.command_options.cwd).join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      parent_dir = path.dirname(this.target());
      if (this.args[0] === '-r') {
        wrench.rmdirSyncRecursive(this.target());
      } else {
        fs.unlinkSync(this.target());
      }
      if (!options.silent) {
        timeLog("removed " + (eb.utils.relativePath(this.target(), this.command_options.cwd)));
      }
      eb.utils.rmdirIfEmpty(parent_dir);
      return typeof callback === "function" ? callback(0, this) : void 0;
    };

    return Remove;

  })();

  eb.command.Copy = (function() {

    function Copy(args, command_options) {
      if (args == null) {
        args = [];
      }
      this.command_options = command_options != null ? command_options : {};
      this.args = eb.utils.resolveArguments(args, this.command_options.cwd);
    }

    Copy.prototype.source = function() {
      return this.args[this.args.length - 2];
    };

    Copy.prototype.target = function() {
      return this.args[this.args.length - 1];
    };

    Copy.prototype.run = function(options, callback) {
      var target_dir;
      if (options == null) {
        options = {};
      }
      if (options.preview || options.verbose) {
        console.log("cp " + (eb.utils.relativeArguments(this.args, this.command_options.cwd).join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      try {
        target_dir = path.dirname(this.target());
        if (!path.existsSync(target_dir)) {
          wrench.mkdirSyncRecursive(target_dir, 0x1ff);
        }
      } catch (e) {
        if (e.code !== 'EEXIST') {
          throw e;
        }
      }
      if (this.args[0] === '-r') {
        wrench.copyDirSyncRecursive(this.source(), this.target());
      } else {
        fs.writeFileSync(this.target(), fs.readFileSync(this.source(), 'utf8'), 'utf8');
      }
      if (!options.silent) {
        timeLog("copied " + (eb.utils.relativePath(this.target(), this.command_options.cwd)));
      }
      return typeof callback === "function" ? callback(0, this) : void 0;
    };

    return Copy;

  })();

  eb.command.Coffee = (function() {

    function Coffee(args, command_options) {
      if (args == null) {
        args = [];
      }
      this.command_options = command_options != null ? command_options : {};
      this.args = eb.utils.resolveArguments(args, this.command_options.cwd);
    }

    Coffee.prototype.targetDirectory = function() {
      var index;
      return eb.utils.safePathNormalize((index = _.indexOf(this.args, '-o')) >= 0 ? "" + this.args[index + 1] : '');
    };

    Coffee.prototype.pathedTargets = function() {
      var index, output_directory, output_names, pathed_source_file, pathed_source_files, pathed_targets, source_name, _i, _j, _len, _len1;
      pathed_targets = [];
      output_directory = this.targetDirectory();
      output_names = (index = _.indexOf(this.args, '-j')) >= 0 ? [this.args[index + 1]] : this.args.slice(_.indexOf(this.args, '-c') + 1);
      for (_i = 0, _len = output_names.length; _i < _len; _i++) {
        source_name = output_names[_i];
        if (source_name.match(/\.js$/) || source_name.match(/\.coffee$/)) {
          pathed_targets.push(eb.utils.safePathNormalize("" + output_directory + "/" + (eb.utils.builtName(path.basename(source_name)))));
        } else {
          pathed_source_files = [];
          globber.glob("" + source_name + "/**/*.coffee").forEach(function(pathed_file) {
            return pathed_source_files.push(pathed_file.replace(source_name, ''));
          });
          for (_j = 0, _len1 = pathed_source_files.length; _j < _len1; _j++) {
            pathed_source_file = pathed_source_files[_j];
            pathed_targets.push(eb.utils.safePathNormalize("" + output_directory + (eb.utils.builtName(pathed_source_file))));
          }
        }
      }
      return pathed_targets;
    };

    Coffee.prototype.isCompressed = function() {
      return this.command_options.compress;
    };

    Coffee.prototype.runsTests = function() {
      return this.command_options.test;
    };

    Coffee.prototype.run = function(options, callback) {
      var notify, spawned,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (options.preview || options.verbose) {
        console.log("coffee " + (eb.utils.relativeArguments(this.args, this.command_options.cwd).join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      spawned = spawn('coffee', this.args, eb.utils.extractCWD(this.command_options));
      spawned.stderr.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      notify = function(code) {
        var build_directory, output_directory, output_names, pathed_build_name, post_build_queue, source_name, _i, _len;
        output_directory = _this.targetDirectory();
        output_names = _this.pathedTargets();
        if (_this.isCompressed() || (_this.runsTests() && _this.already_run)) {
          post_build_queue = new eb.command.Queue();
        }
        for (_i = 0, _len = output_names.length; _i < _len; _i++) {
          source_name = output_names[_i];
          build_directory = eb.utils.resolvePath(output_directory, path.dirname(source_name));
          pathed_build_name = "" + build_directory + "/" + (eb.utils.builtName(path.basename(source_name)));
          if (code === 0) {
            if (!options.silent) {
              timeLog("compiled " + (eb.utils.relativePath(pathed_build_name, _this.targetDirectory())));
            }
          } else {
            timeLog("failed to compile " + (eb.utils.relativePath(pathed_build_name, _this.targetDirectory())) + " .... error code: " + code);
          }
          if (_this.isCompressed()) {
            post_build_queue.push(new eb.command.UglifyJS(['-o', eb.utils.compressedName(pathed_build_name), pathed_build_name], {
              cwd: _this.targetDirectory()
            }));
          }
        }
        if (_this.runsTests() && _this.already_run) {
          post_build_queue.push(new eb.command.RunCommand('cake', ['test'], {
            cwd: _this.command_options.cwd
          }));
        }
        _this.already_run = true;
        if (post_build_queue) {
          return post_build_queue.run(options, function() {
            return typeof callback === "function" ? callback(code, _this) : void 0;
          });
        } else {
          return typeof callback === "function" ? callback(0, _this) : void 0;
        }
      };
      if (options.watch) {
        return spawned.stdout.on('data', function(data) {
          return notify(0);
        });
      } else {
        return spawned.on('exit', function(code) {
          return notify(code);
        });
      }
    };

    return Coffee;

  })();

  eb.command.UglifyJS = (function() {

    function UglifyJS(args, command_options) {
      if (args == null) {
        args = [];
      }
      this.command_options = command_options != null ? command_options : {};
      this.args = eb.utils.resolveArguments(args, this.command_options.cwd);
    }

    UglifyJS.prototype.outputName = function() {
      var index;
      if ((index = _.indexOf(this.args, '-o')) >= 0) {
        return "" + this.args[index + 1];
      } else {
        return '';
      }
    };

    UglifyJS.prototype.run = function(options, callback) {
      var ast, header, header_index, scoped_command, src;
      if (options == null) {
        options = {};
      }
      scoped_command = 'node_modules/.bin/uglifyjs';
      if (options.preview || options.verbose) {
        console.log("" + scoped_command + " " + (eb.utils.relativeArguments(this.args, this.command_options.cwd).join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      try {
        src = fs.readFileSync(this.args[2], 'utf8');
        header = (header_index = src.indexOf('*/')) > 0 ? src.substr(0, header_index + 2) : '';
        ast = uglifyjs.parser.parse(src);
        ast = uglifyjs.uglify.ast_mangle(ast);
        ast = uglifyjs.uglify.ast_squeeze(ast);
        src = header + uglifyjs.uglify.gen_code(ast) + ';';
        fs.writeFileSync(this.args[1], src, 'utf8');
        if (!options.silent) {
          timeLog("compressed " + (eb.utils.relativePath(this.outputName(), this.command_options.cwd)));
        }
        return typeof callback === "function" ? callback(0, this) : void 0;
      } catch (e) {
        timeLog("failed to minify " + (eb.utils.relativePath(this.outputName(), this.command_options.cwd)) + " .... error code: " + e.code);
        return typeof callback === "function" ? callback(e.code, this) : void 0;
      }
    };

    return UglifyJS;

  })();

  eb.command.RunTest = (function() {

    function RunTest(command, args, command_options) {
      this.command = command;
      this.args = args != null ? args : [];
      this.command_options = command_options != null ? command_options : {};
    }

    RunTest.prototype.usingPhantomJS = function() {
      return this.command === 'phantomjs';
    };

    RunTest.prototype.fileName = function() {
      if (this.usingPhantomJS()) {
        return this.args[1];
      } else {
        return this.args[0];
      }
    };

    RunTest.prototype.exitCode = function() {
      return this.exit_code;
    };

    RunTest.prototype.run = function(options, callback) {
      var scoped_args, scoped_command, spawned,
        _this = this;
      if (options == null) {
        options = {};
      }
      scoped_command = this.usingPhantomJS() ? this.command : path.join('node_modules/.bin', this.command);
      scoped_args = _.clone(this.args);
      if (this.usingPhantomJS()) {
        if (this.args[1].search('file://') !== 0) {
          scoped_args[1] = "file://" + (eb.utils.resolvePath(this.args[1], this.command_options.cwd));
        }
      } else {
        scoped_args = eb.utils.relativeArguments(scoped_args, this.command_options.cwd);
      }
      if (options.preview || options.verbose) {
        console.log("" + scoped_command + " " + (scoped_args.join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      spawned = spawn(scoped_command, scoped_args);
      spawned.stderr.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      spawned.stdout.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      return spawned.on('exit', function(code) {
        _this.exit_code = code;
        if (code === 0) {
          if (!options.silent) {
            timeLog("tests passed " + (eb.utils.relativePath(_this.fileName(), _this.command_options.cwd)));
          }
        } else {
          timeLog("tests failed " + (eb.utils.relativePath(_this.fileName(), _this.command_options.cwd)) + " (exit code: " + code + ")");
        }
        return typeof callback === "function" ? callback(code, _this) : void 0;
      });
    };

    return RunTest;

  })();

  eb.command.GitPush = (function() {

    function GitPush(command_options) {
      this.command_options = command_options != null ? command_options : {};
    }

    GitPush.prototype.run = function(options, callback) {
      var git_queue;
      if (options == null) {
        options = {};
      }
      git_queue = new eb.command.Queue();
      git_queue.push(new eb.command.RunCommand('git', ['add', '.'], this.command_options));
      git_queue.push(new eb.command.RunCommand('git', ['rm', '$(git ls-files --deleted)'], this.command_options));
      git_queue.push(new eb.command.RunCommand('git', ['commit'], this.command_options));
      git_queue.push(new eb.command.RunCommand('git', ['push'], this.command_options));
      return git_queue.run(options, function(queue) {
        return typeof callback === "function" ? callback(queue.errorCount(), this) : void 0;
      });
    };

    return GitPush;

  })();

}).call(this);
