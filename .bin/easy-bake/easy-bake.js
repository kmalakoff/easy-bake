// Generated by CoffeeScript 1.3.3
(function() {
  var RESERVED_SETS, RUNNERS_ROOT, TEST_DEFAULT_TIMEOUT, eb, fs, path, print, spawn, timeLog, yaml, _;

  print = require('util').print;

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  if (!global.option) {
    require('coffee-script/lib/coffee-script/cake');
  }

  yaml = require('js-yaml');

  _ = require('underscore');

  RESERVED_SETS = ['postinstall'];

  TEST_DEFAULT_TIMEOUT = 60000;

  RUNNERS_ROOT = "" + __dirname + "/lib/test_runners";

  eb = this.eb = typeof exports !== 'undefined' ? exports : {};

  eb.utils = require('./lib/easy-bake-utils');

  eb.command = require('./lib/easy-bake-commands');

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  eb.Oven = (function() {

    function Oven(YAML_filename) {
      this.YAML_dir = path.dirname(fs.realpathSync(YAML_filename));
      this.YAML = yaml.load(fs.readFileSync(YAML_filename, 'utf8'));
    }

    Oven.prototype.publishOptions = function() {
      global.option('-c', '--clean', 'cleans the project before running a command');
      global.option('-w', '--watch', 'watches for changes');
      global.option('-b', '--build', 'builds the project (used with test)');
      global.option('-p', '--preview', 'display all of the commands that will be run (without running them!)');
      global.option('-v', '--verbose', 'display additional information');
      global.option('-s', '--silent', 'does not output messages to the console (unless errors occur)');
      return this;
    };

    Oven.prototype.publishTasks = function(options) {
      var args, task_name, task_names, tasks, _i, _len,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.publishOptions();
      tasks = {
        postinstall: [
          'Called by npm after installing library', function(options) {
            return _this.postinstall(options);
          }
        ],
        clean: [
          'Remove generated JavaScript files', function(options) {
            return _this.clean(options);
          }
        ],
        build: [
          'Build library and tests', function(options) {
            return _this.build(options);
          }
        ],
        watch: [
          'Watch library and tests', function(options) {
            return _this.build(_.defaults({
              watch: true
            }, options));
          }
        ],
        test: [
          'Test library', function(options) {
            return _this.test(options);
          }
        ],
        publishgit: [
          'Cleans, builds, tests and if successful, runs git commands to add, commit, and push the project', function(options) {
            return _this.publishGit(options);
          }
        ],
        publishnpm: [
          'Cleans, builds, tests and if successful, runs npm commands to publish the project', function(options) {
            return _this.publishNPM(options);
          }
        ]
      };
      task_names = options.tasks ? options.tasks : _.keys(tasks);
      for (_i = 0, _len = task_names.length; _i < _len; _i++) {
        task_name = task_names[_i];
        args = tasks[task_name];
        if (!args) {
          console.log("easy-bake: task name not recognized " + task_name);
          continue;
        }
        if (options.scope) {
          task_name = "" + options.scope + "." + task_name;
        }
        global.task.apply(null, [task_name].concat(args));
      }
      return this;
    };

    Oven.prototype.postinstall = function(options, callback) {
      var command_queue, set, set_name, _ref;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (set_name !== 'postinstall') {
          continue;
        }
        eb.utils.extractSetCommands(set, command_queue, this.YAML_dir);
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("postinstall completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.clean = function(options, callback) {
      var args, build_queue, command, command_queue, output_directory, pathed_build_name, pathed_targets, postinstall_queue, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------clean " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      build_queue = new eb.command.Queue();
      this.build(_.defaults({
        clean: false,
        queue: build_queue
      }, options));
      _ref = build_queue.commands();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        command = _ref[_i];
        if (!(command instanceof eb.command.Coffee)) {
          continue;
        }
        output_directory = command.targetDirectory();
        pathed_targets = command.pathedTargets();
        for (_j = 0, _len1 = pathed_targets.length; _j < _len1; _j++) {
          pathed_build_name = pathed_targets[_j];
          command_queue.push(new eb.command.Remove(["" + pathed_build_name], {
            cwd: this.YAML_dir
          }));
          if (command.isCompressed()) {
            command_queue.push(new eb.command.Remove(["" + (eb.utils.compressedName(pathed_build_name))], {
              cwd: this.YAML_dir
            }));
          }
        }
      }
      postinstall_queue = new eb.command.Queue();
      this.postinstall(_.defaults({
        clean: false
      }, options), postinstall_queue);
      _ref1 = postinstall_queue.commands();
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        command = _ref1[_k];
        if (!(command instanceof eb.command.RunCommand)) {
          continue;
        }
        if (command.command === 'cp') {
          args = [];
          if (command.args[0] === '-r') {
            args.push('-r');
            args.push(path.join(this.YAML_dir, command.args[2]));
          } else {
            args.push(path.join(this.YAML_dir, command.args[1]));
          }
          command_queue.push(new eb.command.Remove(args, {
            cwd: this.YAML_dir
          }));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("clean completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.build = function(options, callback) {
      var args, command_queue, file_group, file_groups, set, set_name, set_options, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      if (options.clean) {
        this.clean(_.defaults({
          queue: command_queue
        }, options));
      }
      this.postinstall(options, command_queue);
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------build " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name)) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, 'build');
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.YAML_dir, options);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          args = [];
          if (options.watch) {
            args.push('-w');
          }
          if (set_options.bare) {
            args.push('-b');
          }
          if (set_options.join) {
            args.push('-j');
            args.push(set_options.join);
          }
          args.push('-o');
          if (set_options.output) {
            args.push(set_options.output);
          } else {
            args.push(this.YAML_dir);
          }
          args.push('-c');
          if (file_group.files) {
            args = args.concat(_.map(file_group.files, function(file) {
              return path.join(file_group.directory, file);
            }));
          } else {
            args.push(file_group.directory);
          }
          command_queue.push(new eb.command.Coffee(args, {
            cwd: file_group.directory,
            compress: set_options.compress,
            test: options.test
          }));
        }
        eb.utils.extractSetCommands(set_options, command_queue, this.YAML_dir);
        eb.utils.extractSetBundles(set_options, command_queue, this.YAML_dir);
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("build completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.test = function(options, callback) {
      var args, command_queue, easy_bake_runner_used, file, file_group, file_groups, length_base, set, set_name, set_options, test_queue, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      if (options.build || options.watch) {
        this.build(_.defaults({
          test: true,
          queue: command_queue
        }, options));
      }
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'tests'));
      if (options.verbose) {
        test_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------test " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name) || !(set.modes && set.modes.hasOwnProperty('test'))) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, 'test');
        if (set_options.runner && !path.existsSync(set_options.runner)) {
          set_options.runner = "" + RUNNERS_ROOT + "/" + set_options.runner;
          easy_bake_runner_used = true;
        }
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.YAML_dir, options);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          if (!file_group.files) {
            throw "missing files for test in set: " + set_name;
          }
          _ref1 = file_group.files;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            file = _ref1[_j];
            args = [];
            if (set_options.runner) {
              args.push(set_options.runner);
            }
            args.push(path.join(file_group.directory, file));
            if (set_options.args) {
              args = args.concat(set_options.args);
            }
            if (easy_bake_runner_used) {
              length_base = set_options.runner ? 2 : 1;
              if (args.length < (length_base + 1)) {
                args.push(TEST_DEFAULT_TIMEOUT);
              }
              if (args.length < (length_base + 2)) {
                args.push(true);
              }
            }
            test_queue.push(new eb.command.RunTest(set_options.command, args, {
              cwd: this.YAML_dir
            }));
          }
        }
        eb.utils.extractSetCommands(set, command_queue, this.YAML_dir);
      }
      if (!options.preview) {
        test_queue.push({
          run: function(run_options, callback, queue) {
            var command, total_error_count, _k, _len2, _ref2;
            if (!(options.preview || options.verbose)) {
              total_error_count = 0;
              console.log("\n-------------GROUP TEST RESULTS--------");
              _ref2 = test_queue.commands();
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                command = _ref2[_k];
                if (!(command instanceof eb.command.RunTest)) {
                  continue;
                }
                total_error_count += command.exitCode() ? 1 : 0;
                console.log("" + (command.exitCode() ? '✖' : '✔') + " " + (eb.utils.relativePath(command.fileName(), _this.YAML_dir)) + (command.exitCode() ? ' (exit code: ' + command.exitCode() + ')' : ''));
              }
              console.log("--------------------------------------");
              console.log(total_error_count ? "All tests ran with with " + total_error_count + " error(s)" : "All tests ran successfully!");
              console.log("--------------------------------------");
            }
            if (typeof callback === "function") {
              callback(0);
            }
            if (!options.watch && !options.no_exit) {
              return process.exit(queue.errorCount() > 0 ? 1 : 0);
            }
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.publishGit = function(options, callback) {
      var chain_options, command_queue, test_queue,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'publishgit'));
      chain_options = _.defaults({
        queue: test_queue
      }, options);
      this.clean(chain_options).postinstall(chain_options).build(chain_options).test(_.defaults({
        no_exit: true
      }, chain_options));
      test_queue.push({
        run: function(run_options, callback, queue) {
          var git_command;
          if (!(options.preview || options.verbose)) {
            if (queue.errorCount()) {
              console.log("publishgit aborted due to " + (queue.errorCount()) + " error(s)");
              if (typeof callback === "function") {
                callback(queue.errorCount());
              }
              return;
            }
          }
          git_command = new eb.command.PublishGit({
            cwd: _this.YAML_dir
          });
          return git_command.run(options, function(code) {
            if (!options.verbose) {
              console.log("publishgit completed with " + code + " error(s)");
            }
            return typeof callback === "function" ? callback(code) : void 0;
          });
        }
      });
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.publishNPM = function(options, callback) {
      var chain_options, command_queue, test_queue,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'publishNPM'));
      chain_options = _.defaults({
        queue: test_queue
      }, options);
      this.clean(chain_options).postinstall(chain_options).build(chain_options).test(_.defaults({
        no_exit: true
      }, chain_options));
      test_queue.push({
        run: function(run_options, callback, queue) {
          var git_command, package_desc, package_desc_path, package_path;
          if (!(options.preview || options.verbose)) {
            if (queue.errorCount()) {
              console.log("publishnpm aborted due to " + (queue.errorCount()) + " error(s)");
              if (typeof callback === "function") {
                callback(queue.errorCount());
              }
              return;
            }
          }
          package_path = path.join(_this.YAML_dir, 'packages', 'npm');
          if (!path.existsSync(package_path)) {
            package_path = _this.YAML_dir;
          }
          package_desc_path = path.join(package_path, 'package.json');
          if (!path.existsSync(package_desc_path)) {
            console.log("no package.json found for publishNPM: " + (package_desc_path.replace(_this.YAML_dir, '')));
            return;
          }
          package_desc = require(package_desc_path);
          if (package_desc.name.search(/\_dev$/) >= 0) {
            console.log("skipping publishnpm for: " + package_desc_path + " (name trails with '_dev')");
            return;
          }
          if (!path.existsSync(path.join(package_path, package_desc.main))) {
            console.log("skipping publishnpm for: " + package_desc_path + " (main file missing...do you need to build it?)");
            return;
          }
          git_command = new eb.command.PublishNPM({
            cwd: package_path
          });
          return git_command.run(options, function(code) {
            if (!options.verbose) {
              console.log("publishgit completed with " + code + " error(s)");
            }
            return typeof callback === "function" ? callback(code) : void 0;
          });
        }
      });
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    return Oven;

  })();

}).call(this);
