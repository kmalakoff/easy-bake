// Generated by CoffeeScript 1.3.3
(function() {
  var eb, fs, globber, path, _;

  fs = require('fs');

  path = require('path');

  _ = require('underscore');

  globber = require('glob-whatev');

  if (!eb) {
    eb = {};
  }

  if (!this.eb) {
    this.eb = {};
  }

  eb.utils = this.eb.utils = typeof exports !== 'undefined' ? exports : {};

  eb.utils.extractSetOptions = function(set, mode, defaults) {
    var set_options;
    set_options = _.clone(set);
    if (set.options) {
      if (set.options['global']) {
        _.extend(set_options, set.options['global']);
      }
      if (set.options[mode]) {
        _.extend(set_options, set.options[mode]);
      }
      delete set_options['options'];
    }
    if (defaults) {
      _.defaults(set_options, defaults);
    }
    return set_options;
  };

  eb.utils.getOptionsFileGroups = function(set_options, cwd, options) {
    var directories, directory, directory_slashed, file_groups, files, found_files, no_files_ok, rel_directory, rel_file, search_query, target_files, unpathed_dir, _i, _j, _len, _len1;
    file_groups = [];
    directories = set_options.hasOwnProperty('directories') ? set_options.directories : (set_options.files ? [cwd] : null);
    if (!directories) {
      return file_groups;
    }
    files = set_options.hasOwnProperty('files') ? set_options.files : null;
    no_files_ok = set_options.hasOwnProperty('no_files_ok') ? set_options.no_files_ok : void 0;
    for (_i = 0, _len = directories.length; _i < _len; _i++) {
      unpathed_dir = directories[_i];
      directory = eb.utils.resolvePath(unpathed_dir, cwd);
      if (!path.existsSync(directory)) {
        console.log("warning: directory is missing " + directory);
        continue;
      }
      directory = fs.realpathSync(directory);
      rel_directory = directory.replace("" + cwd + "/", '');
      if (!files) {
        file_groups.push({
          directory: directory,
          files: null
        });
        continue;
      }
      target_files = [];
      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
        rel_file = files[_j];
        found_files = [];
        search_query = path.join(directory.replace(path.dirname(rel_file), ''), rel_file);
        globber.glob(search_query).forEach(function(target_file) {
          return found_files.push(target_file);
        });
        target_files = target_files.concat(found_files);
        if (found_files.length) {
          continue;
        }
        if (!no_files_ok || !_.contains(no_files_ok, rel_directory)) {
          console.log("warning: file not found " + search_query + ". If you are previewing a test, build your project before previewing.");
        }
      }
      if (!target_files.length) {
        continue;
      }
      directory_slashed = "" + directory + "/";
      file_groups.push({
        directory: directory,
        files: _.map(target_files, function(target_file) {
          return target_file.replace(directory_slashed, '');
        })
      });
    }
    return file_groups;
  };

  eb.utils.relativePath = function(target, cwd) {
    var relative_path;
    if (!cwd || target.search(cwd) !== 0) {
      return target;
    }
    relative_path = target.substr(cwd.length);
    if (relative_path[0] === '/') {
      relative_path = relative_path.substr(1);
    }
    if (relative_path.length) {
      return relative_path;
    } else {
      return '.';
    }
  };

  eb.utils.extractCWD = function(options) {
    if (options == null) {
      options = {};
    }
    if (options.cwd) {
      return {
        cwd: options.cwd
      };
    } else {
      return {};
    }
  };

  eb.utils.runInExecDir = function(fn, cwd) {
    var original_dirname, result;
    if (cwd) {
      original_dirname = fs.realpathSync('.');
      process.chdir(cwd);
      result = fn();
      return process.chdir(original_dirname);
    } else {
      return fn();
    }
  };

  eb.utils.safePathNormalize = function(target, cwd) {
    var normalized_target;
    if (target.substr(0, process.env.HOME.length) === process.env.HOME) {
      return target;
    }
    if (cwd && (target.substr(0, cwd.length) === cwd)) {
      return target;
    }
    normalized_target = target;
    eb.utils.runInExecDir((function() {
      try {
        return normalized_target = path.normalize(target);
      } catch (e) {

      }
    }), cwd);
    return normalized_target;
  };

  eb.utils.safeRequireResolve = function(target, cwd) {
    var resolved_target;
    if (target.substr(0, process.env.HOME.length) === process.env.HOME) {
      return target;
    }
    if (cwd && (target.substr(0, cwd.length) === cwd)) {
      return target;
    }
    resolved_target = target;
    eb.utils.runInExecDir((function() {
      try {
        return resolved_target = require.resolve(target);
      } catch (e) {

      }
    }), cwd);
    return resolved_target;
  };

  eb.utils.resolveArguments = function(args, cwd) {
    return _.map(args, function(arg) {
      if (arg[0] === '-' || !_.isString(arg)) {
        return arg;
      }
      return eb.utils.resolvePath(arg, cwd);
    });
  };

  eb.utils.relativeArguments = function(args, cwd) {
    var _this = this;
    return _.map(args, function(arg) {
      if (arg[0] === '-' || !_.isString(arg)) {
        return arg;
      }
      return eb.utils.relativePath(arg, cwd);
    });
  };

  eb.utils.resolvePath = function(target, cwd) {
    var char, next_char, raw_target, _i, _len;
    target = eb.utils.safeRequireResolve(target, cwd);
    if (target.substr(0, process.env.HOME.length) === process.env.HOME) {
      return target;
    }
    if (cwd && (target.substr(0, cwd.length) === cwd)) {
      return target;
    }
    if (target[0] === '.') {
      for (_i = 0, _len = target.length; _i < _len; _i++) {
        char = target[_i];
        next_char = char;
        if (char !== '.' && char !== '/') {
          break;
        }
      }
      if (next_char === '.' || '/') {
        raw_target = path.join((cwd ? cwd : cwd), target);
      } else {
        raw_target = path.join(cwd, target);
      }
    } else if (target[0] === '~') {
      raw_target = target.replace(/^~/, process.env.HOME);
    } else if (cwd) {
      raw_target = path.join(cwd, target);
    } else {
      raw_target = target;
    }
    return path.normalize(raw_target);
  };

  eb.utils.builtName = function(output_name) {
    return output_name.replace(/\.coffee$/, '.js');
  };

  eb.utils.compressedName = function(output_name) {
    return output_name.replace(/\.js$/, '.min.js');
  };

}).call(this);
