// Generated by CoffeeScript 1.3.3
(function() {
  var eb, fs, path, spawn, timeLog, uglifyjs, wrench, _;

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  _ = require('underscore');

  wrench = require('wrench');

  uglifyjs = require('uglify-js');

  if (!eb) {
    eb = {};
  }

  if (!this.eb) {
    this.eb = {};
  }

  eb.utils = require('./easy-bake-utils');

  eb.command = this.eb.command = typeof exports !== 'undefined' ? exports : {};

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  eb.command.Queue = (function() {

    function Queue() {
      this.commands_queue = [];
      this.is_running = false;
      this.errors = [];
    }

    Queue.prototype.commands = function() {
      return this.commands_queue;
    };

    Queue.prototype.errorCount = function() {
      return this.errors.length;
    };

    Queue.prototype.push = function(command) {
      return this.commands_queue.push(command);
    };

    Queue.prototype.run = function(run_options, callback) {
      var current_index, done, next,
        _this = this;
      if (this.is_running) {
        throw 'queue is already running';
      }
      this.is_running = true;
      this.errors = [];
      current_index = 0;
      done = function() {
        _this.is_running = false;
        return typeof callback === "function" ? callback(_this) : void 0;
      };
      next = function(code, task) {
        if ((code !== 0) && (arguments.length !== 0)) {
          _this.errors.push({
            code: code,
            task: task
          });
        }
        if (++current_index < _this.commands_queue.length) {
          return _this.commands_queue[current_index].run(run_options, next, _this);
        } else {
          return done();
        }
      };
      if (this.commands_queue.length) {
        return this.commands_queue[current_index].run(run_options, next, this);
      } else {
        return done();
      }
    };

    return Queue;

  })();

  eb.command.RunQueue = (function() {

    function RunQueue(run_queue, name) {
      this.run_queue = run_queue;
      this.name = name;
    }

    RunQueue.prototype.queue = function() {
      return this.run_queue;
    };

    RunQueue.prototype.run = function(options, callback) {
      if (options == null) {
        options = {};
      }
      if (options.verbose) {
        console.log("running queue: " + this.name);
      }
      return this.run_queue.run(options, function(queue) {
        return typeof callback === "function" ? callback(queue.errorCount(), this) : void 0;
      });
    };

    return RunQueue;

  })();

  eb.command.Command = (function() {

    function Command(command, args, command_options) {
      this.command = command;
      this.args = args != null ? args : [];
      this.command_options = command_options != null ? command_options : {};
    }

    Command.prototype.run = function(options, callback) {
      var display_args, spawned,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (options.preview || options.verbose) {
        display_args = _.map(this.args, function(arg) {
          return eb.utils.relativePath(arg, _this.command_options.root_dir);
        });
        console.log("" + (this.command_options.cwd ? this.command_options.cwd + ': ' : '') + this.command + " " + (display_args.join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      spawned = spawn(this.command, this.args, this.command_options);
      spawned.stderr.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      spawned.stdout.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      return spawned.on('exit', function(code) {
        return typeof callback === "function" ? callback(code, this) : void 0;
      });
    };

    return Command;

  })();

  eb.command.Clean = (function() {

    function Clean(args, command_options) {
      this.args = args != null ? args : [];
      this.command_options = command_options != null ? command_options : {};
    }

    Clean.prototype.target = function() {
      return this.args[this.args.length - 1];
    };

    Clean.prototype.run = function(options, callback) {
      var display_args,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (!path.existsSync(this.target())) {
        if (typeof callback === "function") {
          callback(0, this);
        }
        return;
      }
      if (options.preview || options.verbose) {
        display_args = _.map(this.args, function(arg) {
          return eb.utils.relativePath(arg, _this.command_options.root_dir);
        });
        console.log("rm " + (display_args.join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      if (this.args[0] === '-r') {
        wrench.rmdirSyncRecursive(this.args[1]);
      } else {
        fs.unlink(this.args[0]);
      }
      return typeof callback === "function" ? callback(0, this) : void 0;
    };

    return Clean;

  })();

  eb.command.Coffee = (function() {

    function Coffee(args, command_options) {
      this.args = args != null ? args : [];
      this.command_options = command_options != null ? command_options : {};
    }

    Coffee.prototype.targetDirectory = function() {
      var index;
      if ((index = _.indexOf(this.args, '-o')) >= 0) {
        return "" + this.args[index + 1];
      } else {
        return '';
      }
    };

    Coffee.prototype.targetNames = function() {
      var index;
      if ((index = _.indexOf(this.args, '-j')) >= 0) {
        return [this.args[index + 1]];
      } else {
        return this.args.slice(_.indexOf(this.args, '-c') + 1);
      }
    };

    Coffee.prototype.isCompressed = function() {
      return this.command_options.compress;
    };

    Coffee.prototype.runsTests = function() {
      return this.command_options.test;
    };

    Coffee.prototype.run = function(options, callback) {
      var display_args, notify, spawned,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (options.preview || options.verbose) {
        display_args = _.map(this.args, function(arg) {
          return eb.utils.relativePath(arg, _this.command_options.root_dir);
        });
        console.log("coffee " + (display_args.join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      spawned = spawn('coffee', this.args);
      spawned.stderr.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      notify = function(code) {
        var build_directory, output_directory, output_names, pathed_build_name, post_build_queue, source_name, _i, _len;
        output_directory = _this.targetDirectory();
        output_names = _this.targetNames();
        if (_this.isCompressed() || (_this.runsTests() && _this.already_run)) {
          post_build_queue = new eb.command.Queue();
        }
        for (_i = 0, _len = output_names.length; _i < _len; _i++) {
          source_name = output_names[_i];
          build_directory = eb.utils.resolvePath(output_directory, {
            cwd: path.dirname(source_name),
            root_dir: _this.command_options.root_dir
          });
          pathed_build_name = "" + build_directory + "/" + (eb.utils.builtName(path.basename(source_name)));
          if (code === 0) {
            if (!options.silent) {
              timeLog("compiled " + (pathed_build_name.replace("" + _this.command_options.root_dir + "/", '')));
            }
          } else {
            timeLog("failed to compile " + (pathed_build_name.replace("" + _this.command_options.root_dir + "/", '')) + " .... error code: " + code);
          }
          if (_this.isCompressed()) {
            post_build_queue.push(new eb.command.UglifyJS(['-o', eb.utils.compressedName(pathed_build_name), pathed_build_name], {
              root_dir: _this.command_options.root_dir
            }));
          }
        }
        if (_this.runsTests() && _this.already_run) {
          post_build_queue.push(new eb.command.Command('cake', ['test'], {
            root_dir: _this.command_options.root_dir
          }));
        }
        _this.already_run = true;
        if (post_build_queue) {
          return post_build_queue.run(options, function() {
            return typeof callback === "function" ? callback(code, _this) : void 0;
          });
        } else {
          return typeof callback === "function" ? callback(0, _this) : void 0;
        }
      };
      if (options.watch) {
        return spawned.stdout.on('data', function(data) {
          return notify(0);
        });
      } else {
        return spawned.on('exit', function(code) {
          return notify(code);
        });
      }
    };

    return Coffee;

  })();

  eb.command.UglifyJS = (function() {

    function UglifyJS(args, command_options) {
      this.args = args != null ? args : [];
      this.command_options = command_options != null ? command_options : {};
    }

    UglifyJS.prototype.outputName = function() {
      var index;
      if ((index = _.indexOf(this.args, '-o')) >= 0) {
        return "" + this.args[index + 1];
      } else {
        return '';
      }
    };

    UglifyJS.prototype.run = function(options, callback) {
      var ast, display_args, header, header_index, scoped_command, src,
        _this = this;
      if (options == null) {
        options = {};
      }
      scoped_command = "node_modules/.bin/uglifyjs";
      if (options.preview || options.verbose) {
        display_args = _.map(this.args, function(arg) {
          return eb.utils.relativePath(arg, _this.command_options.root_dir);
        });
        console.log("" + scoped_command + " " + (display_args.join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      try {
        src = fs.readFileSync(this.args[2], 'utf8');
        header = (header_index = src.indexOf('*/')) > 0 ? src.substr(0, header_index + 2) : '';
        ast = uglifyjs.parser.parse(src);
        ast = uglifyjs.uglify.ast_mangle(ast);
        ast = uglifyjs.uglify.ast_squeeze(ast);
        src = header + uglifyjs.uglify.gen_code(ast) + ';';
        fs.writeFileSync(this.args[1], src, 'utf8');
        if (!options.silent) {
          timeLog("compressed " + (this.outputName().replace("" + this.command_options.root_dir + "/", '')));
        }
        return typeof callback === "function" ? callback(0, this) : void 0;
      } catch (e) {
        timeLog("failed to minify " + (this.outputName().replace("" + this.command_options.root_dir + "/", '')) + " .... error code: " + e.code);
        return typeof callback === "function" ? callback(e.code, this) : void 0;
      }
    };

    return UglifyJS;

  })();

  eb.command.Test = (function() {

    function Test(command, args, command_options) {
      this.command = command;
      this.args = args != null ? args : [];
      this.command_options = command_options != null ? command_options : {};
    }

    Test.prototype.usingPhantomJS = function() {
      return this.command === 'phantomjs';
    };

    Test.prototype.fileName = function() {
      return eb.utils.relativePath((this.usingPhantomJS() ? this.args[1] : this.args[0]), this.command_options.root_dir);
    };

    Test.prototype.exitCode = function() {
      return this.exit_code;
    };

    Test.prototype.run = function(options, callback) {
      var display_args, scoped_args, scoped_command, spawned,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (this.usingPhantomJS()) {
        scoped_command = this.command;
        scoped_args = _.clone(this.args);
        scoped_args[1] = "file://" + this.args[1];
      } else {
        scoped_command = "node_modules/.bin/" + this.command;
        scoped_args = this.args;
      }
      if (options.preview || options.verbose) {
        display_args = scoped_args.length === 4 ? scoped_args.slice(0, scoped_args.length - 1) : scoped_args;
        if (!this.usingPhantomJS()) {
          display_args = _.map(display_args, function(arg) {
            return eb.utils.relativePath(arg, _this.command_options.root_dir);
          });
        }
        console.log("" + scoped_command + " " + (display_args.join(' ')));
        if (options.preview) {
          if (typeof callback === "function") {
            callback(0, this);
          }
          return;
        }
      }
      if (!this.usingPhantomJS()) {
        scoped_args = _.map(scoped_args, function(arg) {
          return eb.utils.relativePath(arg, _this.command_options.root_dir);
        });
      }
      spawned = spawn(scoped_command, scoped_args);
      spawned.stderr.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      spawned.stdout.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      return spawned.on('exit', function(code) {
        _this.exit_code = code;
        if (code === 0) {
          if (!options.silent) {
            timeLog("tests passed " + (_this.fileName()));
          }
        } else {
          timeLog("tests failed " + (_this.fileName()) + " (exit code: " + code + ")");
        }
        return typeof callback === "function" ? callback(code, _this) : void 0;
      });
    };

    return Test;

  })();

  eb.command.GitPush = (function() {

    function GitPush() {}

    GitPush.prototype.run = function(options, callback) {
      var git_queue;
      if (options == null) {
        options = {};
      }
      git_queue = new eb.command.Queue();
      git_queue.push(new eb.command.Command('git', ['add', '.'], {
        root_dir: this.YAML_dir
      }));
      git_queue.push(new eb.command.Command('git', ['commit'], {
        root_dir: this.YAML_dir
      }));
      git_queue.push(new eb.command.Command('git', ['push'], {
        root_dir: this.YAML_dir
      }));
      return git_queue.run(options, function(queue) {
        return typeof callback === "function" ? callback(queue.errorCount(), this) : void 0;
      });
    };

    return GitPush;

  })();

}).call(this);
