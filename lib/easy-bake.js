// Generated by CoffeeScript 1.3.3
(function() {
  var PROJECT_ROOT, RESERVED_SETS, RUNNERS_ROOT, TEST_DEFAULT_TIMEOUT, cake, eb, fs, globber, path, print, spawn, uglifyjs, wrench, yaml, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  print = require('util').print;

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  yaml = require('js-yaml');

  wrench = require('wrench');

  _ = require('underscore');

  globber = require('glob-whatev');

  uglifyjs = require('uglify-js');

  cake = require('coffee-script/lib/coffee-script/cake');

  RESERVED_SETS = ['postinstall'];

  TEST_DEFAULT_TIMEOUT = 60000;

  PROJECT_ROOT = "" + __dirname + "/..";

  RUNNERS_ROOT = "" + PROJECT_ROOT + "/lib/test_runners";

  eb = this.eb = typeof exports !== 'undefined' ? exports : {};

  eb.Baker = (function() {

    function Baker(YAML, options) {
      var args, task_name, task_names, tasks, _i, _len,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.runClean = __bind(this.runClean, this);

      this.YAML_dir = path.dirname(fs.realpathSync(YAML));
      this.YAML = yaml.load(fs.readFileSync(YAML, 'utf8'));
      option('-c', '--clean', 'clean the project');
      option('-w', '--watch', 'watch for changes');
      option('-s', '--silent', 'silence the console output');
      option('-p', '--preview', 'preview the action');
      tasks = {
        clean: [
          'Remove generated JavaScript files', function(options) {
            return _this.clean(options);
          }
        ],
        build: [
          'Build library and tests', function(options) {
            return _this.build(options);
          }
        ],
        watch: [
          'Watch library and tests', function(options) {
            return _this.watch(options);
          }
        ],
        test: [
          'Test library', function(options) {
            return _this.test(options);
          }
        ],
        postinstall: [
          'Performs postinstall actions', function(options) {
            return _this.postinstall(options);
          }
        ]
      };
      task_names = options.tasks ? options.tasks : _.keys(tasks);
      for (_i = 0, _len = task_names.length; _i < _len; _i++) {
        task_name = task_names[_i];
        args = tasks[task_name];
        if (!args) {
          console.log("easy-bake: task name not recognized " + task_name);
          continue;
        }
        if (options.namespace) {
          task_name = "" + options.namespace + "." + task_name;
        }
        task.apply(null, [task_name].concat(args));
      }
    }

    Baker.prototype.timeLog = function(message) {
      return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
    };

    Baker.prototype.resolveDirectory = function(directory, current_root) {
      var stripped_directory;
      if (directory.match(/^\.\//)) {
        stripped_directory = directory.substr('./'.length);
        if (directory === './') {
          return current_root;
        } else {
          return "" + current_root + "/" + stripped_directory;
        }
      } else if (directory === '.') {
        stripped_directory = directory.substr('.'.length);
        return "" + current_root + "/" + stripped_directory;
      } else if (directory[0] === '/') {
        return directory;
      } else if (directory.match(/^\{root\}/)) {
        stripped_directory = directory.substr('{root}'.length);
        if (directory === '{root}') {
          return this.YAML_dir;
        } else {
          return "" + this.YAML_dir + "/" + stripped_directory;
        }
      } else {
        return "" + this.YAML_dir + "/" + directory;
      }
    };

    Baker.prototype.minifiedOutputName = function(output_directory, source_name) {
      output_directory = this.resolveDirectory(output_directory, path.dirname(source_name));
      return "" + output_directory + "/" + (path.basename(source_name).replace(/\.coffee$/, ".js"));
    };

    Baker.prototype.minifiedName = function(output_name) {
      return output_name.replace(/\.js$/, ".min.js");
    };

    Baker.prototype.YAMLRelative = function(pathed_filename) {
      return eb.Utils.removeString(pathed_filename, "" + this.YAML_dir + "/");
    };

    Baker.prototype.runClean = function(array, directory, options) {
      var item, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (!path.existsSync(item)) {
          continue;
        }
        this.timeLog("cleaned " + item);
        if (directory) {
          _results.push(wrench.rmdirSyncRecursive(item));
        } else {
          if (!options.preview) {
            _results.push(fs.unlink(item));
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    Baker.prototype.clean = function(options, command_queue) {
      var directories_to_delete, directory, files_to_delete, owns_queue, resolved_path, set, set_name, set_options, _i, _len, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !!command_queue;
      command_queue || (command_queue = new eb.CommandQueue());
      directories_to_delete = [];
      files_to_delete = [];
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name)) {
          continue;
        }
        set_options = eb.Utils.extractSetOptions(set, 'build', {
          directories: [this.YAML_dir]
        });
        if (set.options && set.options.clean) {
          _.extend(set_options, set.options.clean);
        }
        _ref1 = set_options.directories;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          directory = _ref1[_i];
          if (set_options.output) {
            if (set_options.output[0] === '.') {
              resolved_path = this.resolveDirectory(set_options.output, directory);
            } else {
              if (!path.existsSync(set_options.output)) {
                continue;
              }
              resolved_path = fs.realpathSync(set_options.output);
            }
            directories_to_delete.push(resolved_path);
          } else {
            resolved_path = this.YAML_dir;
          }
          if (set_options.join) {
            files_to_delete.push("" + resolved_path + "/" + set_options.join);
            if (set_options.minimize) {
              files_to_delete.push("" + resolved_path + "/" + (this.minifiedName(set_options.join)));
            }
          }
        }
      }
      if (options.preview) {
        console.log('************clean preview*************');
      }
      this.runClean(directories_to_delete, true, options);
      this.runClean(files_to_delete, false, options);
      if (typeof options.callback === "function") {
        options.callback(0);
      }
      if (owns_queue) {
        return command_queue.run((function(code) {
          return console.log("done: " + code);
        }), options.preview);
      }
    };

    Baker.prototype.minify = function(output_name, options, code) {
      var args, ast, header, header_index, result, src;
      if (options == null) {
        options = {};
      }
      result = code;
      args = ['-o', this.minifiedName(output_name), output_name];
      if (options.preview) {
        console.log("uglifyjs " + (args.join(' ')));
        return typeof options.callback === "function" ? options.callback(result) : void 0;
      } else {
        try {
          src = fs.readFileSync(args[2], 'utf8');
          header = (header_index = src.indexOf('*/')) > 0 ? src.substr(0, header_index + 2) : '';
          ast = uglifyjs.parser.parse(src);
          ast = uglifyjs.uglify.ast_mangle(ast);
          ast = uglifyjs.uglify.ast_squeeze(ast);
          src = header + uglifyjs.uglify.gen_code(ast) + ';';
          fs.writeFileSync(args[1], src, 'utf8');
          if (!options.silent) {
            this.timeLog("minified " + (this.YAMLRelative(output_name)));
          }
          return typeof options.callback === "function" ? options.callback(result) : void 0;
        } catch (e) {
          this.timeLog("failed to minify " + (this.YAMLRelative(output_name)) + " .... error code: " + e.code);
          return typeof options.callback === "function" ? options.callback(result | e.code) : void 0;
        }
      }
    };

    Baker.prototype.runCoffee = function(args, options) {
      var notify, spawned,
        _this = this;
      if (options == null) {
        options = {};
      }
      spawned = spawn('coffee', args);
      spawned.stderr.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      notify = function(code) {
        var build_filename, filenames, index, original_callback, output_directory, output_name, source_name, _i, _len;
        output_directory = (index = _.indexOf(args, '-o')) >= 0 ? "" + args[index + 1] : '';
        filenames = (index = _.indexOf(args, '-j')) >= 0 ? [args[index + 1]] : filenames = args.slice(_.indexOf(args, '-c') + 1);
        original_callback = options.callback;
        options = _.clone(options);
        options.callback = null;
        options.callback = eb.Utils.afterWithCollect(filenames.length, function(result) {
          if (original_callback) {
            result |= original_callback(result);
          }
          return result;
        });
        for (_i = 0, _len = filenames.length; _i < _len; _i++) {
          source_name = filenames[_i];
          output_name = _this.minifiedOutputName(output_directory, source_name);
          build_filename = _this.YAMLRelative(output_name);
          if (code === 0) {
            if (!options.silent) {
              _this.timeLog("built " + build_filename);
            }
          } else {
            _this.timeLog("failed to build " + build_filename + " .... error code: code");
          }
          if (options.minimize) {
            _this.minify(output_name, options, code);
          }
        }
        if (!options.minimize) {
          return typeof original_callback === "function" ? original_callback(code) : void 0;
        }
      };
      if (options.watch) {
        return spawned.stdout.on('data', function(data) {
          return notify(0);
        });
      } else {
        return spawned.on('exit', function(code) {
          return notify(code);
        });
      }
    };

    Baker.prototype.build = function(options, command_queue) {
      var args, coffee_commands_to_run, file_group, file_groups, original_callback, owns_queue, run_build_fn, set, set_name, set_options, _i, _len, _ref,
        _this = this;
      if (options == null) {
        options = {};
      }
      owns_queue = !!command_queue;
      command_queue || (command_queue = new eb.CommandQueue());
      coffee_commands_to_run = [];
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name)) {
          continue;
        }
        set_options = eb.Utils.extractSetOptions(set, 'build', {
          directories: ['.'],
          files: ['**/*.coffee']
        });
        file_groups = eb.Utils.setOptionsFileGroups(set_options, this.YAML_dir);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          args = [];
          if (options.watch) {
            args.push('-w');
          }
          if (set_options.bare) {
            args.push('-b');
          }
          if (set_options.join) {
            args.push(['-j', set_options.join]);
          }
          if (set_options.output) {
            args.push(['-o', this.resolveDirectory(set_options.output, file_group.directory)]);
          } else {
            args.push(['-o', this.YAML_dir]);
          }
          args.push(['-c', file_group.files]);
          coffee_commands_to_run.push({
            args: _.flatten(args),
            minimize: set_options.minimize
          });
        }
      }
      original_callback = options.callback;
      options = _.clone(options);
      options.callback = null;
      run_build_fn = function(code) {
        var coffee_command, filenames, index, minimize, output_directory, output_name, source_name, spawned, _j, _k, _l, _len1, _len2, _len3, _results;
        if (options.preview) {
          console.log('************build preview*************');
          for (_j = 0, _len1 = coffee_commands_to_run.length; _j < _len1; _j++) {
            coffee_command = coffee_commands_to_run[_j];
            args = coffee_command.args;
            minimize = coffee_command;
            console.log("coffee " + (args.join(' ')));
            if (coffee_command.minimize) {
              output_directory = (index = _.indexOf(args, '-o')) >= 0 ? "" + args[index + 1] : '';
              filenames = (index = _.indexOf(args, '-j')) >= 0 ? [args[index + 1]] : filenames = args.slice(_.indexOf(args, '-c') + 1);
              for (_k = 0, _len2 = filenames.length; _k < _len2; _k++) {
                source_name = filenames[_k];
                output_name = _this.minifiedOutputName(output_directory, source_name);
                console.log(output_name);
                if (minimize) {
                  _this.minify(output_name, options, code);
                }
              }
            }
          }
          return spawned = spawn('uglifyjs', typeof original_callback === "function" ? original_callback(0) : void 0);
        } else {
          options.callback = eb.Utils.afterWithCollect(coffee_commands_to_run.length, function(result) {
            if (original_callback) {
              result |= original_callback(result);
            }
            return result;
          });
          _results = [];
          for (_l = 0, _len3 = coffee_commands_to_run.length; _l < _len3; _l++) {
            coffee_command = coffee_commands_to_run[_l];
            _results.push(_this.runCoffee(coffee_command.args, _.extend(_.clone(options), {
              minimize: coffee_command.minimize
            })));
          }
          return _results;
        }
      };
      if (options.clean) {
        this.clean(_.extend(_.clone(options), {
          callback: run_build_fn
        }));
      } else {
        run_build_fn(0);
      }
      if (owns_queue) {
        return command_queue.run((function(code) {
          return console.log("done: " + code);
        }), options.preview);
      }
    };

    Baker.prototype.watch = function(options) {
      if (options == null) {
        options = {};
      }
      return this.build(_.extend(options, {
        watch: true
      }));
    };

    Baker.prototype.runTest = function(command, args, options) {
      var spawned,
        _this = this;
      if (options == null) {
        options = {};
      }
      spawned = spawn(command, args);
      spawned.stdout.on('data', function(data) {
        return process.stderr.write(data.toString());
      });
      return spawned.on('exit', function(code) {
        var test_filename;
        test_filename = eb.Utils.removeString(args[1], "file://" + _this.YAML_dir + "/");
        if (code === 0) {
          if (!options.silent) {
            _this.timeLog("tests passed " + test_filename);
          }
        } else {
          _this.timeLog("tests failed " + test_filename + " .... error code: " + code);
        }
        code !== (typeof options.callback === "function" ? options.callback(code) : void 0);
        return code;
      });
    };

    Baker.prototype.test = function(options, command_queue) {
      var args, file, file_group, file_groups, original_callback, owns_queue, run_tests_fn, set, set_name, set_options, tests_to_run, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      if (options == null) {
        options = {};
      }
      owns_queue = !!command_queue;
      command_queue || (command_queue = new eb.CommandQueue());
      tests_to_run = [];
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name) || !(set.options && set.options.hasOwnProperty('test'))) {
          continue;
        }
        set_options = eb.Utils.extractSetOptions(set, 'test', {
          timeout: TEST_DEFAULT_TIMEOUT,
          directories: ['.'],
          command: 'phantomjs',
          files: ['**/*.html']
        });
        if (set_options.runner) {
          if (!path.existsSync(set_options.runner)) {
            set_options.runner = "" + RUNNERS_ROOT + "/" + set_options.runner;
          }
        }
        file_groups = eb.Utils.setOptionsFileGroups(set_options, this.YAML_dir);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          _ref1 = file_group.files;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            file = _ref1[_j];
            args = [];
            if (set_options.runner) {
              args.push(set_options.runner);
            }
            args.push("file://" + (fs.realpathSync(file)));
            if (set_options.timeout) {
              args.push(set_options.timeout);
            }
            tests_to_run.push({
              command: set_options.command,
              args: args
            });
          }
        }
      }
      original_callback = options.callback;
      options = _.clone(options);
      options.callback = null;
      run_tests_fn = function() {
        var test_to_run, _k, _l, _len2, _len3, _results;
        if (options.preview) {
          console.log('************test preview**************');
          for (_k = 0, _len2 = tests_to_run.length; _k < _len2; _k++) {
            test_to_run = tests_to_run[_k];
            console.log("" + est_to_run.command + " " + (test_to_run.args.join(' ')));
          }
          return typeof original_callback === "function" ? original_callback(0) : void 0;
        } else {
          _this.timeLog("************tests started*************");
          options.callback = eb.Utils.afterWithCollect(tests_to_run.length, function(result) {
            if (result) {
              _this.timeLog("************tests failed**************");
            } else {
              _this.timeLog("************tests succeeded***********");
            }
            if (original_callback) {
              result |= original_callback(result);
            }
            if (!options.watch) {
              process.exit(result);
            }
            return result;
          });
          _results = [];
          for (_l = 0, _len3 = tests_to_run.length; _l < _len3; _l++) {
            test_to_run = tests_to_run[_l];
            _results.push(_this.runTest(test_to_run.command, test_to_run.args, options));
          }
          return _results;
        }
      };
      this.build(_.extend(_.clone(options), {
        callback: run_tests_fn,
        clean: options.clean
      }));
      if (owns_queue) {
        return command_queue.run((function(code) {
          return console.log("done: " + code);
        }), options.preview);
      }
    };

    Baker.prototype.postinstall = function(options, command_queue) {
      var file, file_group, file_groups, owns_queue, set, set_name, set_options, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !!command_queue;
      command_queue || (command_queue = new eb.CommandQueue());
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (set_name !== 'postinstall') {
          continue;
        }
        if (set.options.vendor) {
          set_options = eb.Utils.extractSetOptions(set, 'vendor', {
            output: 'vendor'
          });
          file_groups = eb.Utils.setOptionsFileGroups(set_options, this.YAML_dir);
          for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
            file_group = file_groups[_i];
            _ref1 = file_group.files;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              file = _ref1[_j];
              command_queue.push(new eb.command.CopyFile(this, file, set_options.output));
            }
          }
        }
      }
      if (owns_queue) {
        return command_queue.run((function(code) {
          return console.log("done: " + code);
        }), options.preview);
      }
    };

    return Baker;

  })();

  eb.Utils = (function() {

    function Utils() {}

    Utils.removeString = function(string, remove_string) {
      return string.replace(remove_string, '');
    };

    Utils.extractSetOptions = function(set, mode, defaults) {
      var set_options;
      set_options = _.clone(set);
      if (set.options) {
        if (set.options['global']) {
          _.extend(set_options, set.options['global']);
        }
        if (set.options[mode]) {
          _.extend(set_options, set.options[mode]);
        }
        delete set_options['options'];
      }
      if (defaults) {
        _.defaults(set_options, defaults);
      }
      return set_options;
    };

    Utils.setOptionsFileGroups = function(set_options, YAML_dir) {
      var directories, directory, file_groups, files, no_files_ok, pathed_files, _i, _len;
      file_groups = [];
      directories = set_options.hasOwnProperty('directories') ? set_options.directories : ['.'];
      files = set_options.hasOwnProperty('files') ? set_options.files : ['**/*'];
      no_files_ok = set_options.hasOwnProperty('no_files_ok') ? set_options.no_files_ok : void 0;
      for (_i = 0, _len = directories.length; _i < _len; _i++) {
        directory = directories[_i];
        if (!path.existsSync(directory)) {
          console.log("warning: directory is missing " + directory);
          continue;
        }
        directory = fs.realpathSync(directory);
        pathed_files = [];
        _.each(files, function(rel_file) {
          var count, rel_directory;
          count = pathed_files.length;
          globber.glob("" + directory + "/" + rel_file).forEach(function(pathed_file) {
            return pathed_files.push(pathed_file);
          });
          if (count === pathed_files.length) {
            rel_directory = eb.Utils.removeString(directory, "" + YAML_dir + "/");
            if (!no_files_ok || !_.contains(no_files_ok, rel_directory)) {
              return console.log("warning: files not found " + directory + "/" + rel_file);
            }
          }
        });
        if (!pathed_files.length) {
          continue;
        }
        file_groups.push({
          directory: directory,
          files: pathed_files
        });
      }
      return file_groups;
    };

    Utils.afterWithCollect = function(count, callback) {
      return function(code) {
        var result;
        if (_.isUndefined(result)) {
          result = code;
        }
        result !== code;
        if (--count > 0) {
          return result;
        }
        result |= callback(result);
        return result;
      };
    };

    return Utils;

  })();

  eb.command || (eb.command = {});

  eb.CommandQueue = (function() {

    function CommandQueue() {
      this.commands = [];
      this.is_running = false;
    }

    CommandQueue.prototype.push = function(command) {
      return this.commands.push(command);
    };

    CommandQueue.prototype.run = function(callback, preview) {
      var current_index, done, next,
        _this = this;
      if (this.is_running) {
        throw 'queue is already running';
      }
      this.is_running = true;
      this.errors = [];
      current_index = 0;
      done = function() {
        _this.is_running = false;
        if (_this.errors.length) {
          console.log('commands failed');
        }
        return typeof callback === "function" ? callback(_this.errors.length) : void 0;
      };
      next = function(code, task) {
        if (code !== 0) {
          errors.push({
            code: code,
            task: task
          });
        }
        if (++current_index < _this.commands.length) {
          return _this.commands[current_index].run(next, preview);
        } else {
          return done();
        }
      };
      if (this.commands.length) {
        return this.commands[current_index].run(next, preview);
      } else {
        return done();
      }
    };

    return CommandQueue;

  })();

  eb.command.CopyFile = (function() {

    function CopyFile(baker, src, to_directory) {
      this.baker = baker;
      this.src = src;
      this.to_directory = to_directory;
    }

    CopyFile.prototype.run = function(callback, preview) {
      var spawned,
        _this = this;
      if (preview) {
        console.log("cp " + this.src + " " + this.to_directory);
        return typeof callback === "function" ? callback(0, this) : void 0;
      } else {
        spawned = spawn('cp', [this.src, this.to_directory]);
        spawned.stderr.on('data', function(data) {
          process.stderr.write(data.toString());
          return typeof callback === "function" ? callback(code, this) : void 0;
        });
        return spawned.on('exit', function(code) {
          console.log("copied " + (_this.baker.YAMLRelative(_this.src)) + " " + _this.to_directory);
          return typeof callback === "function" ? callback(code, _this) : void 0;
        });
      }
    };

    return CopyFile;

  })();

}).call(this);
