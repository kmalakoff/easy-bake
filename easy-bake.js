// Generated by CoffeeScript 1.3.3
(function() {
  var RESERVED_SETS, RUNNERS_ROOT, TEST_DEFAULT_TIMEOUT, eb, ebc, fs, globber, path, print, spawn, timeLog, yaml, _;

  print = require('util').print;

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  yaml = require('js-yaml');

  _ = require('underscore');

  ebc = require('./lib/easy-bake-commands');

  require('coffee-script/lib/coffee-script/cake');

  RESERVED_SETS = ['postinstall'];

  TEST_DEFAULT_TIMEOUT = 60000;

  RUNNERS_ROOT = "" + __dirname + "/lib/test_runners";

  eb = this.eb = typeof exports !== 'undefined' ? exports : {};

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  eb.Baker = (function() {

    function Baker(YAML, options) {
      var args, task_name, task_names, tasks, _i, _len,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.YAML_dir = path.dirname(fs.realpathSync(YAML));
      this.YAML = yaml.load(fs.readFileSync(YAML, 'utf8'));
      option('-c', '--clean', 'clean the project');
      option('-w', '--watch', 'watch for changes');
      option('-s', '--silent', 'silence the console output');
      option('-p', '--preview', 'preview the action');
      option('-v', '--verbose', 'display additional information');
      tasks = {
        clean: [
          'Remove generated JavaScript files', function(options) {
            return _this.clean(options);
          }
        ],
        build: [
          'Build library and tests', function(options) {
            return _this.build(options);
          }
        ],
        watch: [
          'Watch library and tests', function(options) {
            return _this.watch(options);
          }
        ],
        test: [
          'Test library', function(options) {
            return _this.test(options);
          }
        ],
        postinstall: [
          'Performs postinstall actions', function(options) {
            return _this.postinstall(options);
          }
        ]
      };
      task_names = options.tasks ? options.tasks : _.keys(tasks);
      for (_i = 0, _len = task_names.length; _i < _len; _i++) {
        task_name = task_names[_i];
        args = tasks[task_name];
        if (!args) {
          console.log("easy-bake: task name not recognized " + task_name);
          continue;
        }
        if (options.namespace) {
          task_name = "" + options.namespace + "." + task_name;
        }
        task.apply(null, [task_name].concat(args));
      }
    }

    Baker.prototype.resolveDirectory = function(directory, current_root) {
      var stripped_directory;
      if (directory.match(/^\.\//)) {
        stripped_directory = directory.substr('./'.length);
        if (directory === './') {
          return current_root;
        } else {
          return "" + current_root + "/" + stripped_directory;
        }
      } else if (directory === '.') {
        stripped_directory = directory.substr('.'.length);
        return "" + current_root + "/" + stripped_directory;
      } else if (directory[0] === '/') {
        return directory;
      } else if (directory.match(/^\{root\}/)) {
        stripped_directory = directory.substr('{root}'.length);
        if (directory === '{root}') {
          return this.YAML_dir;
        } else {
          return "" + this.YAML_dir + "/" + stripped_directory;
        }
      } else {
        return "" + this.YAML_dir + "/" + directory;
      }
    };

    Baker.prototype.minifiedOutputName = function(output_directory, source_name) {
      output_directory = this.resolveDirectory(output_directory, path.dirname(source_name));
      return "" + output_directory + "/" + (path.basename(source_name).replace(/\.coffee$/, ".js"));
    };

    Baker.prototype.minifiedName = function(output_name) {
      return output_name.replace(/\.js$/, ".min.js");
    };

    Baker.prototype.clean = function(options, command_queue) {
      var directory, owns_queue, resolved_path, set, set_name, set_options, _i, _len, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new ebc.Queue());
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("************clean " + (options.preview ? 'started (PREVIEW)' : 'started') + "************");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name)) {
          continue;
        }
        set_options = eb.Utils.extractSetOptions(set, 'build', {
          directories: [this.YAML_dir]
        });
        if (set.options && set.options.clean) {
          _.extend(set_options, set.options.clean);
        }
        _ref1 = set_options.directories;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          directory = _ref1[_i];
          if (set_options.output) {
            if ((set_options.output[0] === '.') || (set_options.output.match(/^\{root\}/))) {
              resolved_path = this.resolveDirectory(set_options.output, directory);
            } else {
              if (!path.existsSync(set_options.output)) {
                continue;
              }
              resolved_path = fs.realpathSync(set_options.output);
            }
            command_queue.push(new ebc.RunClean(['-r', resolved_path], {
              root_dir: this.YAML_dir
            }));
          } else {
            resolved_path = this.YAML_dir;
          }
          if (set_options.join) {
            command_queue.push(new ebc.RunClean(["" + resolved_path + "/" + set_options.join], {
              root_dir: this.YAML_dir
            }));
            if (set_options.minimize) {
              command_queue.push(new ebc.RunClean(["" + resolved_path + "/" + (this.minifiedName(set_options.join))], {
                root_dir: this.YAML_dir
              }));
            }
          }
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("clean completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    Baker.prototype.watch = function(options, command_queue) {
      if (options == null) {
        options = {};
      }
      return this.build(_.defaults({
        watch: true
      }, options), command_queue);
    };

    Baker.prototype.build = function(options, command_queue) {
      var args, coffee_command, file_group, file_groups, output_directory, output_name, owns_queue, set, set_name, set_options, source_name, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new ebc.Queue());
      if (options.clean) {
        this.clean(options, command_queue);
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("************build " + (options.preview ? 'started (PREVIEW)' : 'started') + "************");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name)) {
          continue;
        }
        set_options = eb.Utils.extractSetOptions(set, 'build', {
          directories: ['.'],
          files: ['**/*.coffee']
        });
        file_groups = eb.Utils.setOptionsFileGroups(set_options, this.YAML_dir);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          args = [];
          if (options.watch) {
            args.push('-w');
          }
          if (set_options.bare) {
            args.push('-b');
          }
          if (set_options.join) {
            args.push(['-j', set_options.join]);
          }
          if (set_options.output) {
            args.push(['-o', this.resolveDirectory(set_options.output, file_group.directory)]);
          } else {
            args.push(['-o', this.YAML_dir]);
          }
          args.push(['-c', file_group.files]);
          coffee_command = new ebc.RunCoffee(_.flatten(args), {
            root_dir: this.YAML_dir
          });
          command_queue.push(coffee_command);
          if (set_options.minimize) {
            output_directory = coffee_command.targetDirectory();
            _ref1 = coffee_command.targetNames();
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              source_name = _ref1[_j];
              output_name = this.minifiedOutputName(output_directory, source_name);
              command_queue.push(new ebc.RunUglifyJS(['-o', this.minifiedName(output_name), output_name], {
                root_dir: this.YAML_dir
              }));
            }
          }
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("build completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    Baker.prototype.test = function(options, command_queue) {
      var args, easy_bake_runner_used, file, file_group, file_groups, owns_queue, set, set_name, set_options, test_queue, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new ebc.Queue());
      this.build(options, command_queue);
      test_queue = new ebc.Queue();
      command_queue.push(new ebc.RunQueue(test_queue, 'tests'));
      if (options.verboe) {
        test_queue.push({
          run: function(callback, options, queue) {
            console.log("************test " + (options.preview ? 'started (PREVIEW)' : 'started') + "************");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name) || !(set.options && set.options.hasOwnProperty('test'))) {
          continue;
        }
        set_options = eb.Utils.extractSetOptions(set, 'test', {
          directories: ['.'],
          files: ['**/*.html']
        });
        if (set_options.runner && !path.existsSync(set_options.runner)) {
          set_options.runner = "" + RUNNERS_ROOT + "/" + set_options.runner;
          easy_bake_runner_used = true;
        }
        file_groups = eb.Utils.setOptionsFileGroups(set_options, this.YAML_dir);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          _ref1 = file_group.files;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            file = _ref1[_j];
            args = [];
            if (set_options.runner) {
              args.push(set_options.runner);
            }
            if (set_options.command === 'phantomjs') {
              args.push("file://" + (fs.realpathSync(file)));
            } else {
              args.push(file.replace(this.YAML_dir, ''));
            }
            if (easy_bake_runner_used) {
              args.push(set_options.timeout ? set_options.timeout : TEST_DEFAULT_TIMEOUT);
              args.push(true);
            } else {
              if (set_options.timeout) {
                args.push(set_options.timeout);
              }
              if (set_options.silent) {
                args.push(set_options.silent);
              }
            }
            test_queue.push(new ebc.RunTest(set_options.command, args, {
              root_dir: this.YAML_dir
            }));
          }
        }
      }
      test_queue.push({
        run: function(callback, options, queue) {
          if (options.verbose) {
            console.log("test completed with " + (queue.errorCount()) + " error(s)");
          }
          if (typeof callback === "function") {
            callback();
          }
          if (!options.watch) {
            return process.exit(queue.errorCount() > 0 ? 1 : 0);
          }
        }
      });
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    Baker.prototype.postinstall = function(options, command_queue) {
      var command_info, name, owns_queue, set, set_name, _ref;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new ebc.Queue());
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (set_name !== 'postinstall') {
          continue;
        }
        for (name in set) {
          command_info = set[name];
          if (!command_info.command) {
            console.log("postinstall " + set_name + "." + name + " is not a command");
            continue;
          }
          command_queue.push(new ebc.RunCommand(command_info.command, command_info.args, _.defaults({
            root_dir: this.YAML_dir
          }, command_info.options)));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("postinstall completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    return Baker;

  })();

  globber = require('glob-whatev');

  eb.Utils = (function() {

    function Utils() {}

    Utils.extractSetOptions = function(set, mode, defaults) {
      var set_options;
      set_options = _.clone(set);
      if (set.options) {
        if (set.options['global']) {
          _.extend(set_options, set.options['global']);
        }
        if (set.options[mode]) {
          _.extend(set_options, set.options[mode]);
        }
        delete set_options['options'];
      }
      if (defaults) {
        _.defaults(set_options, defaults);
      }
      return set_options;
    };

    Utils.setOptionsFileGroups = function(set_options, YAML_dir) {
      var directories, directory, file_groups, files, no_files_ok, pathed_files, _i, _len;
      file_groups = [];
      directories = set_options.hasOwnProperty('directories') ? set_options.directories : ['.'];
      files = set_options.hasOwnProperty('files') ? set_options.files : ['**/*'];
      no_files_ok = set_options.hasOwnProperty('no_files_ok') ? set_options.no_files_ok : void 0;
      for (_i = 0, _len = directories.length; _i < _len; _i++) {
        directory = directories[_i];
        if (!path.existsSync(directory)) {
          console.log("warning: directory is missing " + directory);
          continue;
        }
        directory = fs.realpathSync(directory);
        pathed_files = [];
        _.each(files, function(rel_file) {
          var count, rel_directory;
          count = pathed_files.length;
          globber.glob("" + directory + "/" + rel_file).forEach(function(pathed_file) {
            return pathed_files.push(pathed_file);
          });
          if (count === pathed_files.length) {
            rel_directory = directory.replace("" + YAML_dir + "/", '');
            if (!no_files_ok || !_.contains(no_files_ok, rel_directory)) {
              return console.log("warning: files not found " + directory + "/" + rel_file);
            }
          }
        });
        if (!pathed_files.length) {
          continue;
        }
        file_groups.push({
          directory: directory,
          files: pathed_files
        });
      }
      return file_groups;
    };

    return Utils;

  })();

}).call(this);
