// Generated by CoffeeScript 1.3.3
(function() {
  var RESERVED_SETS, RUNNERS_ROOT, TEST_DEFAULT_TIMEOUT, eb, fs, path, print, spawn, timeLog, yaml, _;

  print = require('util').print;

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  yaml = require('js-yaml');

  _ = require('underscore');

  require('coffee-script/lib/coffee-script/cake');

  RESERVED_SETS = ['postinstall'];

  TEST_DEFAULT_TIMEOUT = 60000;

  RUNNERS_ROOT = "" + __dirname + "/lib/test_runners";

  eb = this.eb = typeof exports !== 'undefined' ? exports : {};

  eb.utils = require('./lib/easy-bake-utils');

  eb.commands = require('./lib/easy-bake-commands');

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  eb.Baker = (function() {

    function Baker(YAML, options) {
      var args, task_name, task_names, tasks, _i, _len,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.YAML_dir = path.dirname(fs.realpathSync(YAML));
      this.YAML = yaml.load(fs.readFileSync(YAML, 'utf8'));
      option('-c', '--clean', 'clean the project');
      option('-w', '--watch', 'watch for changes');
      option('-s', '--silent', 'silence the console output');
      option('-p', '--preview', 'preview the action');
      option('-v', '--verbose', 'display additional information');
      tasks = {
        clean: [
          'Remove generated JavaScript files', function(options) {
            return _this.clean(options);
          }
        ],
        build: [
          'Build library and tests', function(options) {
            return _this.build(options);
          }
        ],
        watch: [
          'Watch library and tests', function(options) {
            return _this.watch(options);
          }
        ],
        test: [
          'Test library', function(options) {
            return _this.test(options);
          }
        ],
        postinstall: [
          'Performs postinstall actions', function(options) {
            return _this.postinstall(options);
          }
        ]
      };
      task_names = options.tasks ? options.tasks : _.keys(tasks);
      for (_i = 0, _len = task_names.length; _i < _len; _i++) {
        task_name = task_names[_i];
        args = tasks[task_name];
        if (!args) {
          console.log("easy-bake: task name not recognized " + task_name);
          continue;
        }
        if (options.namespace) {
          task_name = "" + options.namespace + "." + task_name;
        }
        task.apply(null, [task_name].concat(args));
      }
    }

    Baker.prototype.clean = function(options, command_queue) {
      var build_directory, build_queue, command, output_directory, output_names, owns_queue, pathed_build_name, source_name, _i, _j, _len, _len1, _ref;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.commands.Queue());
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("************clean " + (options.preview ? 'started (PREVIEW)' : 'started') + "************");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      build_queue = new eb.commands.Queue();
      this.build(_.defaults({
        clean: false
      }, options), build_queue);
      _ref = build_queue.commands();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        command = _ref[_i];
        if (!(command instanceof eb.commands.RunCoffee)) {
          continue;
        }
        output_directory = command.targetDirectory();
        output_names = command.targetNames();
        for (_j = 0, _len1 = output_names.length; _j < _len1; _j++) {
          source_name = output_names[_j];
          build_directory = eb.utils.resolvePath(output_directory, path.dirname(source_name), this.YAML_dir);
          pathed_build_name = "" + build_directory + "/" + (eb.utils.builtName(path.basename(source_name)));
          command_queue.push(new eb.commands.RunClean(["" + pathed_build_name], {
            root_dir: this.YAML_dir
          }));
          if (command.isCompressed()) {
            command_queue.push(new eb.commands.RunClean(["" + (eb.utils.compressedName(pathed_build_name))], {
              root_dir: this.YAML_dir
            }));
          }
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("clean completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    Baker.prototype.watch = function(options, command_queue) {
      if (options == null) {
        options = {};
      }
      return this.build(_.defaults({
        watch: true
      }, options), command_queue);
    };

    Baker.prototype.build = function(options, command_queue) {
      var args, file_group, file_groups, owns_queue, set, set_name, set_options, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.commands.Queue());
      if (options.clean) {
        this.clean(options, command_queue);
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("************build " + (options.preview ? 'started (PREVIEW)' : 'started') + "************");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name)) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, 'build', {
          directories: ['.'],
          files: ['**/*.coffee']
        });
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.YAML_dir);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          args = [];
          if (options.watch) {
            args.push('-w');
          }
          if (set_options.bare) {
            args.push('-b');
          }
          if (set_options.join) {
            args.push(['-j', set_options.join]);
          }
          if (set_options.output) {
            args.push(['-o', eb.utils.resolvePath(set_options.output, file_group.directory, this.YAML_dir)]);
          } else {
            args.push(['-o', this.YAML_dir]);
          }
          args.push(['-c', file_group.files]);
          command_queue.push(new eb.commands.RunCoffee(_.flatten(args), {
            root_dir: this.YAML_dir,
            compress: set_options.compress
          }));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("build completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    Baker.prototype.test = function(options, command_queue) {
      var args, easy_bake_runner_used, file, file_group, file_groups, owns_queue, set, set_name, set_options, test_queue, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.commands.Queue());
      this.build(options, command_queue);
      test_queue = new eb.commands.Queue();
      command_queue.push(new eb.commands.RunQueue(test_queue, 'tests'));
      if (options.verboe) {
        test_queue.push({
          run: function(callback, options, queue) {
            console.log("************test " + (options.preview ? 'started (PREVIEW)' : 'started') + "************");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name) || !(set.options && set.options.hasOwnProperty('test'))) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, 'test', {
          directories: ['.'],
          files: ['**/*.html']
        });
        if (set_options.runner && !path.existsSync(set_options.runner)) {
          set_options.runner = "" + RUNNERS_ROOT + "/" + set_options.runner;
          easy_bake_runner_used = true;
        }
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.YAML_dir);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          _ref1 = file_group.files;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            file = _ref1[_j];
            args = [];
            if (set_options.runner) {
              args.push(set_options.runner);
            }
            if (set_options.command === 'phantomjs') {
              args.push("file://" + (fs.realpathSync(file)));
            } else {
              args.push(file.replace(this.YAML_dir, ''));
            }
            if (easy_bake_runner_used) {
              args.push(set_options.timeout ? set_options.timeout : TEST_DEFAULT_TIMEOUT);
              args.push(true);
            } else {
              if (set_options.timeout) {
                args.push(set_options.timeout);
              }
              if (set_options.silent) {
                args.push(set_options.silent);
              }
            }
            test_queue.push(new eb.commands.RunTest(set_options.command, args, {
              root_dir: this.YAML_dir
            }));
          }
        }
      }
      test_queue.push({
        run: function(callback, options, queue) {
          if (options.verbose) {
            console.log("test completed with " + (queue.errorCount()) + " error(s)");
          }
          if (typeof callback === "function") {
            callback();
          }
          if (!options.watch) {
            return process.exit(queue.errorCount() > 0 ? 1 : 0);
          }
        }
      });
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    Baker.prototype.postinstall = function(options, command_queue) {
      var command_info, name, owns_queue, set, set_name, _ref;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.commands.Queue());
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (set_name !== 'postinstall') {
          continue;
        }
        for (name in set) {
          command_info = set[name];
          if (!command_info.command) {
            console.log("postinstall " + set_name + "." + name + " is not a command");
            continue;
          }
          command_queue.push(new eb.commands.RunCommand(command_info.command, command_info.args, _.defaults({
            root_dir: this.YAML_dir
          }, command_info.options)));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(callback, options, queue) {
            console.log("postinstall completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        return command_queue.run(null, options);
      }
    };

    return Baker;

  })();

}).call(this);
