// Generated by CoffeeScript 1.3.3
(function() {
  var RESERVED_SETS, RUNNERS_ROOT, TEST_DEFAULT_TIMEOUT, eb, fs, path, print, spawn, timeLog, yaml, _;

  print = require('util').print;

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  yaml = require('js-yaml');

  _ = require('underscore');

  if (!global.option) {
    require('coffee-script/lib/coffee-script/cake');
  }

  RESERVED_SETS = ['postinstall'];

  TEST_DEFAULT_TIMEOUT = 60000;

  RUNNERS_ROOT = "" + __dirname + "/lib/test_runners";

  eb = this.eb = typeof exports !== 'undefined' ? exports : {};

  eb.utils = require('./lib/easy-bake-utils');

  eb.command = require('./lib/easy-bake-commands');

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  eb.Oven = (function() {

    function Oven(YAML_filename) {
      this.YAML_dir = path.dirname(fs.realpathSync(YAML_filename));
      this.YAML = yaml.load(fs.readFileSync(YAML_filename, 'utf8'));
    }

    Oven.prototype.publishOptions = function() {
      global.option('-c', '--clean', 'cleans the project before running a command');
      global.option('-w', '--watch', 'watches for changes');
      global.option('-b', '--build', 'builds the project (used with test)');
      global.option('-p', '--preview', 'display all of the commands that will be run (without running them!)');
      global.option('-v', '--verbose', 'display additional information');
      global.option('-s', '--silent', 'does not output messages to the console (unless errors occur)');
      return this;
    };

    Oven.prototype.publishTasks = function(options) {
      var args, task_name, task_names, tasks, _i, _len,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.publishOptions();
      tasks = {
        clean: [
          'Remove generated JavaScript files', function(options) {
            return _this.clean(options);
          }
        ],
        build: [
          'Build library and tests', function(options) {
            return _this.build(options);
          }
        ],
        watch: [
          'Watch library and tests', function(options) {
            return _this.build(_.defaults({
              watch: true
            }, options));
          }
        ],
        test: [
          'Test library', function(options) {
            return _this.test(options);
          }
        ],
        postinstall: [
          'Called by npm after installing library', function(options) {
            return _this.postinstall(options);
          }
        ],
        gitpush: [
          'Cleans, builds, tests and if successful, runs git commands to add, commit, and push the project', function(options) {
            return _this.gitPush(options);
          }
        ]
      };
      task_names = options.tasks ? options.tasks : _.keys(tasks);
      for (_i = 0, _len = task_names.length; _i < _len; _i++) {
        task_name = task_names[_i];
        args = tasks[task_name];
        if (!args) {
          console.log("easy-bake: task name not recognized " + task_name);
          continue;
        }
        if (options.namespace) {
          task_name = "" + options.namespace + "." + task_name;
        }
        global.task.apply(null, [task_name].concat(args));
      }
      return this;
    };

    Oven.prototype.clean = function(options, command_queue) {
      var args, build_directory, build_queue, command, output_directory, output_names, owns_queue, pathed_build_name, postinstall_queue, source_name, target, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.command.Queue());
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------clean " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      build_queue = new eb.command.Queue();
      this.build(_.defaults({
        clean: false
      }, options), build_queue);
      _ref = build_queue.commands();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        command = _ref[_i];
        if (!(command instanceof eb.command.Coffee)) {
          continue;
        }
        output_directory = command.targetDirectory();
        output_names = command.targetNames();
        for (_j = 0, _len1 = output_names.length; _j < _len1; _j++) {
          source_name = output_names[_j];
          build_directory = eb.utils.resolvePath(output_directory, {
            cwd: path.dirname(source_name),
            root_dir: this.YAML_dir
          });
          pathed_build_name = "" + build_directory + "/" + (eb.utils.builtName(path.basename(source_name)));
          command_queue.push(new eb.command.Clean(["" + pathed_build_name], {
            root_dir: this.YAML_dir
          }));
          if (command.isCompressed()) {
            command_queue.push(new eb.command.Clean(["" + (eb.utils.compressedName(pathed_build_name))], {
              root_dir: this.YAML_dir
            }));
          }
        }
      }
      postinstall_queue = new eb.command.Queue();
      this.postinstall(_.defaults({
        clean: false
      }, options), postinstall_queue);
      _ref1 = postinstall_queue.commands();
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        command = _ref1[_k];
        if (!(command instanceof eb.command.Command)) {
          continue;
        }
        if (command.command === 'cp') {
          target = "" + this.YAML_dir + "/" + command.args[1];
          args = [];
          if (!path.basename(target)) {
            args.push('-r');
          }
          args.push(target);
          command_queue.push(new eb.command.Clean(args, {
            root_dir: this.YAML_dir
          }));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("clean completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        command_queue.run(options);
      }
      return this;
    };

    Oven.prototype.build = function(options, command_queue) {
      var args, file, file_group, file_groups, owns_queue, set, set_name, set_options, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.command.Queue());
      if (options.clean) {
        this.clean(options, command_queue);
      }
      this.postinstall(options, command_queue);
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------build " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name)) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, 'build', {
          directories: ['.'],
          files: ['**/*.coffee']
        });
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.YAML_dir, options);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          args = [];
          if (options.watch) {
            args.push('-w');
          }
          if (set_options.bare) {
            args.push('-b');
          }
          if (set_options.join) {
            args.push('-j');
            args.push(set_options.join);
          }
          args.push('-o');
          if (set_options.output) {
            args.push(eb.utils.resolvePath(set_options.output, {
              cwd: file_group.directory,
              root_dir: this.YAML_dir
            }));
          } else {
            args.push(this.YAML_dir);
          }
          args.push('-c');
          _ref1 = file_group.files;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            file = _ref1[_j];
            args.push(file);
          }
          command_queue.push(new eb.command.Coffee(args, {
            root_dir: this.YAML_dir,
            compress: set_options.compress,
            test: options.test
          }));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("build completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        command_queue.run(options);
      }
      return this;
    };

    Oven.prototype.test = function(options, command_queue) {
      var args, easy_bake_runner_used, file, file_group, file_groups, length_base, owns_queue, set, set_name, set_options, test_queue, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.command.Queue());
      if (options.build || options.watch) {
        this.build(_.defaults({
          test: true
        }, options), command_queue);
      }
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'tests'));
      if (options.verbose) {
        test_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------test " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (_.contains(RESERVED_SETS, set_name) || !(set.options && set.options.hasOwnProperty('test'))) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, 'test', {
          directories: ['.'],
          files: ['**/*.html']
        });
        if (set_options.runner && !path.existsSync(set_options.runner)) {
          set_options.runner = "" + RUNNERS_ROOT + "/" + set_options.runner;
          easy_bake_runner_used = true;
        }
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.YAML_dir, options);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          _ref1 = file_group.files;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            file = _ref1[_j];
            args = [];
            if (set_options.runner) {
              args.push(set_options.runner);
            }
            args.push(eb.utils.resolvePath(file, {
              cwd: file_group.directory,
              root_dir: this.YAML_dir
            }));
            if (set_options.args) {
              args = args.concat(set_options.args);
            }
            if (easy_bake_runner_used) {
              length_base = set_options.runner ? 2 : 1;
              if (args.length < (length_base + 1)) {
                args.push(TEST_DEFAULT_TIMEOUT);
              }
              if (args.length < (length_base + 2)) {
                args.push(true);
              }
            }
            test_queue.push(new eb.command.Test(set_options.command, args, {
              root_dir: this.YAML_dir
            }));
          }
        }
      }
      if (!options.preview) {
        test_queue.push({
          run: function(run_options, callback, queue) {
            var command, total_error_count, _k, _len2, _ref2;
            if (!(options.preview || options.verbose)) {
              total_error_count = 0;
              console.log("\n-------------GROUP TEST RESULTS--------");
              _ref2 = test_queue.commands();
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                command = _ref2[_k];
                if (!(command instanceof eb.command.Test)) {
                  continue;
                }
                total_error_count += command.exitCode() ? 1 : 0;
                console.log("" + (command.exitCode() ? '✖' : '✔') + " " + (command.fileName()) + (command.exitCode() ? ' (exit code: ' + command.exitCode() + ')' : ''));
              }
              console.log("--------------------------------------");
              console.log(total_error_count ? "All tests ran with with " + total_error_count + " error(s)" : "All tests ran successfully!");
              console.log("--------------------------------------");
            }
            if (typeof callback === "function") {
              callback(0);
            }
            if (!options.watch && !options.no_exit) {
              return process.exit(queue.errorCount() > 0 ? 1 : 0);
            }
          }
        });
      }
      if (owns_queue) {
        command_queue.run(options);
      }
      return this;
    };

    Oven.prototype.postinstall = function(options, command_queue) {
      var command_info, name, owns_queue, set, set_name, _ref;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.command.Queue());
      _ref = this.YAML;
      for (set_name in _ref) {
        set = _ref[set_name];
        if (set_name !== 'postinstall') {
          continue;
        }
        for (name in set) {
          command_info = set[name];
          if (!command_info.command) {
            console.log("postinstall " + set_name + "." + name + " is not a command");
            continue;
          }
          command_queue.push(new eb.command.Command(command_info.command, command_info.args, _.defaults({
            root_dir: this.YAML_dir
          }, command_info.options)));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("postinstall completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (owns_queue) {
        command_queue.run(options);
      }
      return this;
    };

    Oven.prototype.gitPush = function(options, command_queue) {
      var owns_queue, test_queue;
      if (options == null) {
        options = {};
      }
      owns_queue = !command_queue;
      command_queue || (command_queue = new eb.command.Queue());
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'gitpush'));
      this.clean(options, test_queue).postinstall(options, test_queue).build(options, test_queue).test(_.defaults({
        no_exit: true
      }, options), test_queue);
      test_queue.push({
        run: function(run_options, callback, queue) {
          var git_command;
          if (!(options.preview || options.verbose)) {
            if (queue.errorCount()) {
              console.log("gitpush aborted due to " + (queue.errorCount()) + " error(s)");
              if (typeof callback === "function") {
                callback(queue.errorCount());
              }
              return;
            }
          }
          git_command = new eb.command.GitPush();
          return git_command.run(options, function(code) {
            if (!options.verbose) {
              console.log("gitpush completed with " + code + " error(s)");
            }
            return typeof callback === "function" ? callback(code) : void 0;
          });
        }
      });
      if (owns_queue) {
        command_queue.run(options);
      }
      return this;
    };

    return Oven;

  })();

}).call(this);
