// Generated by CoffeeScript 1.3.3
var EasyBake, TEST_DEFAULT_TIMEOUT, Utils, fs, globber, path, print, spawn, wrench, yaml, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

print = require('util').print;

spawn = require('child_process').spawn;

fs = require('fs');

path = require('path');

yaml = require('js-yaml');

wrench = require('wrench');

_ = require('underscore');

globber = require('glob-whatev');

TEST_DEFAULT_TIMEOUT = 60000;

Utils = (function() {

  function Utils() {}

  Utils.extractSetOptions = function(set, mode, defaults) {
    var set_options;
    set_options = _.clone(set);
    if (set.options) {
      if (set.options['global']) {
        _.extend(set_options, set.options['global']);
      }
      if (set.options[mode]) {
        _.extend(set_options, set.options[mode]);
      }
      delete set_options['options'];
    }
    if (defaults) {
      _.defaults(set_options, defaults);
    }
    return set_options;
  };

  Utils.setOptionsFileGroups = function(set_options, YAML_dir) {
    var directories, directory, file_groups, files, no_files_ok, pathed_files, _i, _len;
    file_groups = [];
    directories = set_options.hasOwnProperty('directories') ? set_options.directories : ['.'];
    files = set_options.hasOwnProperty('files') ? set_options.files : ['**/*'];
    no_files_ok = set_options.hasOwnProperty('no_files_ok') ? set_options.no_files_ok : void 0;
    for (_i = 0, _len = directories.length; _i < _len; _i++) {
      directory = directories[_i];
      if (!path.existsSync(directory)) {
        console.log("warning: directory is missing " + directory);
        continue;
      }
      directory = fs.realpathSync(directory);
      pathed_files = [];
      _.each(files, function(rel_file) {
        var count, rel_directory;
        count = pathed_files.length;
        globber.glob("" + directory + "/" + rel_file).forEach(function(pathed_file) {
          return pathed_files.push(pathed_file);
        });
        if (count === pathed_files.length) {
          rel_directory = directory.replace("" + YAML_dir + "/", '');
          if (!no_files_ok || !_.contains(no_files_ok, rel_directory)) {
            return console.log("warning: files not found " + directory + "/" + rel_file);
          }
        }
      });
      if (!pathed_files.length) {
        continue;
      }
      file_groups.push({
        directory: directory,
        files: pathed_files
      });
    }
    return file_groups;
  };

  Utils.afterWithCollect = function(count, callback) {
    return function(code) {
      var result;
      if (_.isUndefined(result)) {
        result = code;
      }
      result !== code;
      if (--count > 0) {
        return result;
      }
      result |= callback(result);
      return result;
    };
  };

  return Utils;

})();

EasyBake = (function() {

  function EasyBake(YAML, tasks) {
    this.runClean = __bind(this.runClean, this);

    var _this = this;
    this.YAML_dir = path.dirname(fs.realpathSync(YAML));
    this.YAML = yaml.load(fs.readFileSync(YAML, 'utf8'));
    option('-c', '--clean', 'clean the project');
    option('-w', '--watch', 'watch for changes');
    option('-s', '--silent', 'silence the console output');
    option('-p', '--preview', 'preview the action');
    if (!tasks || _.contains(tasks, 'clean')) {
      task('clean', 'Remove generated JavaScript files', function(options) {
        return _this.clean(options);
      });
    }
    task('build', 'Build library and tests', function(options) {
      if (!tasks || _.contains(tasks, 'build')) {
        return _this.build(options);
      }
    });
    task('watch', 'Watch library and tests', function(options) {
      if (!tasks || _.contains(tasks, 'watch')) {
        return _this.watch(options);
      }
    });
    task('test', 'Test library', function(options) {
      if (!tasks || _.contains(tasks, 'test')) {
        return _this.test(options);
      }
    });
  }

  EasyBake.prototype.timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  EasyBake.prototype.resolveDirectory = function(directory, current_root) {
    var stripped_directory;
    if (directory[0] === '.') {
      stripped_directory = directory[1] === '/' ? directory.substr(2) : directory.substr(1);
      return "" + current_root + "/" + stripped_directory;
    } else if (directory[0] === '/') {
      return directory;
    } else {
      return "" + this.YAML_dir + "/" + directory;
    }
  };

  EasyBake.prototype.minifiedName = function(src) {
    return src.replace(/\.js$/, ".min.js");
  };

  EasyBake.prototype.runClean = function(array, directory, options) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (!path.existsSync(item)) {
        continue;
      }
      this.timeLog("cleaned " + item);
      if (directory) {
        _results.push(wrench.rmdirSyncRecursive(item));
      } else {
        if (!options.preview) {
          _results.push(fs.unlink(item));
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  EasyBake.prototype.clean = function(options) {
    var directories_to_delete, directory, files_to_delete, resolved_path, set, set_name, set_options, _i, _len, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    directories_to_delete = [];
    files_to_delete = [];
    _ref = this.YAML;
    for (set_name in _ref) {
      set = _ref[set_name];
      set_options = Utils.extractSetOptions(set, 'build', {
        directories: [this.YAML_dir]
      });
      if (set.options && set.options.clean) {
        _.extend(set_options, set.options.clean);
      }
      _ref1 = set_options.directories;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        directory = _ref1[_i];
        if (set_options.output) {
          if (set_options.output[0] === '.') {
            resolved_path = this.resolveDirectory(set_options.output, directory);
          } else {
            if (!path.existsSync(set_options.output)) {
              continue;
            }
            resolved_path = fs.realpathSync(set_options.output);
          }
          directories_to_delete.push(resolved_path);
        } else {
          resolved_path = this.YAML_dir;
        }
        if (set_options.join) {
          files_to_delete.push("" + resolved_path + "/" + set_options.join);
          if (set_options.minimize) {
            files_to_delete.push("" + resolved_path + "/" + (this.minifiedName(set_options.join)));
          }
        }
      }
    }
    if (options.preview) {
      console.log('************clean preview*************');
    }
    this.runClean(directories_to_delete, true, options);
    this.runClean(files_to_delete, false, options);
    return typeof options.callback === "function" ? options.callback(0) : void 0;
  };

  EasyBake.prototype.minify = function(src, options, code) {
    var result, spawned,
      _this = this;
    if (options == null) {
      options = {};
    }
    result = code;
    spawned = spawn("" + __dirname + "/node_modules/.bin/uglifyjs", ['-o', this.minifiedName(src), src]);
    return spawned.on('exit', function(code) {
      result |= code;
      if (!options.silent) {
        _this.timeLog("minified " + (src.replace("" + _this.YAML_dir + "/", '')));
      }
      return typeof options.callback === "function" ? options.callback(result) : void 0;
    });
  };

  EasyBake.prototype.runCoffee = function(args, options) {
    var filenames, index, notify, output_directory, source_name, spawned,
      _this = this;
    if (options == null) {
      options = {};
    }
    output_directory = (index = _.indexOf(args, '-o')) >= 0 ? "" + args[index + 1] : '';
    if ((index = _.indexOf(args, '-j')) >= 0) {
      source_name = args[index + 1];
    } else {
      filenames = args.slice(_.indexOf(args, '-c') + 1);
    }
    spawned = spawn("" + __dirname + "/node_modules/.bin/coffee", args);
    spawned.stderr.on('data', function(data) {
      return process.stderr.write(data.toString());
    });
    notify = function(code) {
      var original_callback, output_name, _i, _len;
      if (filenames) {
        original_callback = options.callback;
        options = _.clone(options);
        options.callback = null;
        options.callback = Utils.afterWithCollect(filenames.length, function(result) {
          if (original_callback) {
            result |= original_callback(result);
          }
          return result;
        });
        for (_i = 0, _len = filenames.length; _i < _len; _i++) {
          source_name = filenames[_i];
          output_directory = _this.resolveDirectory(output_directory, path.dirname(source_name));
          output_name = "" + output_directory + "/" + (path.basename(source_name).replace(/\.coffee$/, ".js"));
          if (!options.silent) {
            _this.timeLog("built " + (output_name.replace("" + _this.YAML_dir + "/", '')));
          }
          if (options.minimize) {
            _this.minify(output_name, options, code);
          }
        }
        if (!options.minimize) {
          return typeof original_callback === "function" ? original_callback(code) : void 0;
        }
      } else {
        output_directory = _this.resolveDirectory(output_directory, path.dirname(source_name));
        output_name = "" + output_directory + "/" + (path.basename(source_name).replace(/\.coffee$/, ".js"));
        if (!options.silent) {
          _this.timeLog("built " + (output_name.replace("" + _this.YAML_dir + "/", '')));
        }
        if (options.minimize) {
          return _this.minify(output_name, options, code);
        } else {
          return typeof options.callback === "function" ? options.callback(code) : void 0;
        }
      }
    };
    if (options.watch) {
      return spawned.stdout.on('data', function(data) {
        return notify(0);
      });
    } else {
      return spawned.on('exit', function(code) {
        return notify(code);
      });
    }
  };

  EasyBake.prototype.build = function(options) {
    var args, coffee_commands_to_run, file_group, file_groups, original_callback, run_build_fn, set, set_name, set_options, _i, _len, _ref,
      _this = this;
    if (options == null) {
      options = {};
    }
    coffee_commands_to_run = [];
    _ref = this.YAML;
    for (set_name in _ref) {
      set = _ref[set_name];
      set_options = Utils.extractSetOptions(set, 'build', {
        directories: ['.'],
        files: ['**/*.coffee']
      });
      file_groups = Utils.setOptionsFileGroups(set_options, this.YAML_dir);
      for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
        file_group = file_groups[_i];
        args = [];
        if (options.watch) {
          args.push('-w');
        }
        if (set_options.bare) {
          args.push('-b');
        }
        if (set_options.join) {
          args.push(['-j', set_options.join]);
        }
        if (set_options.output) {
          args.push(['-o', this.resolveDirectory(set_options.output, file_group.directory)]);
        } else {
          args.push(['-o', this.YAML_dir]);
        }
        args.push(['-c', file_group.files]);
        coffee_commands_to_run.push({
          args: _.flatten(args),
          minimize: set_options.minimize
        });
      }
    }
    original_callback = options.callback;
    options = _.clone(options);
    options.callback = null;
    run_build_fn = function(code) {
      var coffee_command, _j, _k, _len1, _len2, _results;
      if (options.preview) {
        console.log('************build preview*************');
        for (_j = 0, _len1 = coffee_commands_to_run.length; _j < _len1; _j++) {
          coffee_command = coffee_commands_to_run[_j];
          console.log("coffee " + (coffee_command.args.join(' ')) + (coffee_command.minimize ? ' ***minimized***' : ''));
        }
        return typeof original_callback === "function" ? original_callback(0) : void 0;
      } else {
        options.callback = Utils.afterWithCollect(coffee_commands_to_run.length, function(result) {
          if (original_callback) {
            result |= original_callback(result);
          }
          return result;
        });
        _results = [];
        for (_k = 0, _len2 = coffee_commands_to_run.length; _k < _len2; _k++) {
          coffee_command = coffee_commands_to_run[_k];
          _results.push(_this.runCoffee(coffee_command.args, _.extend(_.clone(options), {
            minimize: coffee_command.minimize
          })));
        }
        return _results;
      }
    };
    if (options.clean) {
      return this.clean(_.extend(_.clone(options), {
        callback: run_build_fn
      }));
    } else {
      return run_build_fn(0);
    }
  };

  EasyBake.prototype.watch = function(options) {
    if (options == null) {
      options = {};
    }
    return this.build(_.extend(options, {
      watch: true
    }));
  };

  EasyBake.prototype.runTest = function(args, options) {
    var spawned,
      _this = this;
    if (options == null) {
      options = {};
    }
    spawned = spawn('phantomjs', args);
    spawned.stdout.on('data', function(data) {
      return process.stderr.write(data.toString());
    });
    return spawned.on('exit', function(code) {
      var test_filename;
      test_filename = args[1].replace("file://" + _this.YAML_dir + "/", '');
      if (code === 0) {
        if (!options.silent) {
          _this.timeLog("tests passed " + test_filename);
        }
      } else {
        _this.timeLog("tests failed " + test_filename);
      }
      code !== (typeof options.callback === "function" ? options.callback(code) : void 0);
      return code;
    });
  };

  EasyBake.prototype.test = function(options) {
    var file, file_group, file_groups, original_callback, run_tests_fn, set, set_name, set_options, tests_to_run, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    if (options == null) {
      options = {};
    }
    tests_to_run = [];
    _ref = this.YAML;
    for (set_name in _ref) {
      set = _ref[set_name];
      if (!(set.options && set.options.test)) {
        continue;
      }
      set_options = Utils.extractSetOptions(set, 'test', {
        timeout: TEST_DEFAULT_TIMEOUT,
        directories: ['.'],
        files: ['**/*.html']
      });
      if (!path.existsSync(set_options.runner)) {
        set_options.runner = "" + __dirname + "/lib/" + set_options.runner;
      }
      file_groups = Utils.setOptionsFileGroups(set_options, this.YAML_dir);
      for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
        file_group = file_groups[_i];
        _ref1 = file_group.files;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          file = _ref1[_j];
          tests_to_run.push({
            args: [set_options.runner, "file://" + (fs.realpathSync(file)), set_options.timeout]
          });
        }
      }
    }
    original_callback = options.callback;
    options = _.clone(options);
    options.callback = null;
    run_tests_fn = function() {
      var test_to_run, _k, _l, _len2, _len3, _results;
      if (options.preview) {
        console.log('************test preview**************');
        for (_k = 0, _len2 = tests_to_run.length; _k < _len2; _k++) {
          test_to_run = tests_to_run[_k];
          console.log("phantomjs " + (test_to_run.args.join(' ')));
        }
        return typeof original_callback === "function" ? original_callback(0) : void 0;
      } else {
        _this.timeLog("************tests started*************");
        options.callback = Utils.afterWithCollect(tests_to_run.length, function(result) {
          if (result) {
            _this.timeLog("************tests failed**************");
          } else {
            _this.timeLog("************tests succeeded***********");
          }
          if (original_callback) {
            result |= original_callback(result);
          }
          if (!options.watch) {
            process.exit(result);
          }
          return result;
        });
        _results = [];
        for (_l = 0, _len3 = tests_to_run.length; _l < _len3; _l++) {
          test_to_run = tests_to_run[_l];
          _results.push(_this.runTest(test_to_run.args, options));
        }
        return _results;
      }
    };
    return this.build(_.extend(_.clone(options), {
      callback: run_tests_fn,
      clean: options.clean
    }));
  };

  return EasyBake;

})();

module.exports = function(YAML, tasks) {
  return new EasyBake(YAML, tasks);
};
