// Generated by CoffeeScript 1.3.3
(function() {
  var RUNNERS_ROOT, TEST_DEFAULT_TIMEOUT, coffeescript, eb, et, fs, path, print, spawn, _, _base, _ref;

  print = require('util').print;

  spawn = require('child_process').spawn;

  fs = require('fs');

  path = require('path');

  coffeescript = require('coffee-script');

  if (!global.option) {
    require('coffee-script/lib/coffee-script/cake');
  }

  _ = require('underscore');

  et = require('elementtree');

  TEST_DEFAULT_TIMEOUT = 60000;

  RUNNERS_ROOT = "" + __dirname + "/lib/test_runners";

  eb = this.eb = typeof exports !== 'undefined' ? exports : {};

  eb.utils = require('./lib/easy-bake-utils');

  eb.command = require('./lib/easy-bake-commands');

  if ((_ref = (_base = require.extensions)['.coffee']) == null) {
    _base['.coffee'] = function(module, filename) {
      var content;
      content = coffeescript.compile(fs.readFileSync(filename, 'utf8', {
        filename: filename
      }));
      return module._compile(content, filename);
    };
  }

  eb.Oven = (function() {

    function Oven(config, options) {
      var config_pathed_filename, length;
      if (options == null) {
        options = {};
      }
      if (_.isString(config)) {
        config_pathed_filename = fs.realpathSync(config);
        this.config_dir = path.dirname(config_pathed_filename);
        try {
          this.config = require(config_pathed_filename);
        } catch (error) {
          throw "couldn\'t load config " + config + ". " + error;
        }
      } else {
        if (!options.cwd) {
          throw "options are missing current working directory (cwd)";
        }
        this.config = config;
        this.config_dir = path.normalize(options.cwd);
        length = this.config_dir.length;
        if (this.config_dir[length - 1] === '/') {
          this.config_dir = this.config_dir.slice(0, length - 1);
        }
      }
      if (!_.size(this.config)) {
        console.log("warning: an empty config file was loaded: " + config_pathed_filename);
      }
    }

    Oven.prototype.publishOptions = function() {
      global.option('-c', '--clean', 'cleans the project before running a command');
      global.option('-w', '--watch', 'watches for changes');
      global.option('-b', '--build', 'builds the project (used with test)');
      global.option('-p', '--preview', 'display all of the commands that will be run (without running them!)');
      global.option('-v', '--verbose', 'display additional information');
      global.option('-s', '--silent', 'does not output messages to the console (unless errors occur)');
      global.option('-f', '--force', 'forces the action to occur');
      global.option('-q', '--quick', 'performs minimal task');
      return this;
    };

    Oven.prototype.publishTasks = function(options) {
      var args, task_name, task_names, tasks, _i, _len,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.publishOptions();
      tasks = {
        postinstall: [
          'Called by npm after installing library', function(options) {
            return _this.postinstall(options);
          }
        ],
        clean: [
          'Remove generated JavaScript files', function(options) {
            return _this.clean(options);
          }
        ],
        build: [
          'Build library and tests', function(options) {
            return _this.build(options);
          }
        ],
        watch: [
          'Watch library and tests', function(options) {
            return _this.build(_.defaults({
              watch: true
            }, options));
          }
        ],
        test: [
          'Test library', function(options) {
            return _this.test(options);
          }
        ],
        publish_git: [
          'Cleans, builds, tests and if successful, runs git commands to add, commit, and push the project', function(options) {
            return _this.publishGit(options);
          }
        ],
        publish_npm: [
          'Cleans, builds, tests and if successful, runs npm commands to publish the project', function(options) {
            return _this.publishNPM(options);
          }
        ],
        publish_nuget: [
          'Cleans, builds, tests and if successful, runs nuget commands to publish the project', function(options) {
            return _this.publishNuGet(options);
          }
        ],
        publish_all: [
          'Cleans, builds, tests and if successful, commands to publish the project in all available repositories', function(options) {
            return _this.publishAll(options);
          }
        ]
      };
      task_names = options.tasks ? options.tasks : _.keys(tasks);
      for (_i = 0, _len = task_names.length; _i < _len; _i++) {
        task_name = task_names[_i];
        args = tasks[task_name];
        if (!args) {
          console.log("easy-bake: task name not recognized " + task_name);
          continue;
        }
        if (options.scope) {
          task_name = "" + options.scope + "." + task_name;
        }
        global.task.apply(null, [task_name].concat(args));
      }
      return this;
    };

    Oven.prototype.postinstall = function(options, callback) {
      var command_queue, set, set_name, _ref1;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      _ref1 = this.config;
      for (set_name in _ref1) {
        set = _ref1[set_name];
        if (set_name !== '_postinstall') {
          continue;
        }
        eb.utils.extractSetCommands(set, command_queue, this.config_dir);
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("postinstall completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.clean = function(options, callback) {
      var build_queue, command, command_queue, output_directory, pathed_build_name, pathed_targets, postinstall_queue, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------clean " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      build_queue = new eb.command.Queue();
      this.build(_.defaults({
        clean: false,
        queue: build_queue
      }, options));
      _ref1 = build_queue.commands();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        command = _ref1[_i];
        if (!(command instanceof eb.command.Coffee)) {
          continue;
        }
        output_directory = command.targetDirectory();
        pathed_targets = command.pathedTargets();
        for (_j = 0, _len1 = pathed_targets.length; _j < _len1; _j++) {
          pathed_build_name = pathed_targets[_j];
          command_queue.push(new eb.command.Remove(["" + pathed_build_name], {
            cwd: this.config_dir
          }));
          if (command.isCompressed()) {
            command_queue.push(new eb.command.Remove(["" + (eb.utils.compressedName(pathed_build_name))], {
              cwd: this.config_dir
            }));
          }
        }
      }
      postinstall_queue = new eb.command.Queue();
      this.postinstall(_.defaults({
        clean: false,
        queue: postinstall_queue
      }, options));
      _ref2 = postinstall_queue.commands();
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        command = _ref2[_k];
        if (!command.createUndoCommand) {
          continue;
        }
        command_queue.push(command.createUndoCommand());
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("clean completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.build = function(options, callback) {
      var args, command_queue, file_group, file_groups, set, set_name, set_options, _i, _len, _ref1;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      if (options.clean) {
        this.clean(_.defaults({
          queue: command_queue
        }, options));
      }
      this.postinstall(options, command_queue);
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------build " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref1 = this.config;
      for (set_name in _ref1) {
        set = _ref1[set_name];
        if (set_name.startsWith('_')) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, '_build');
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.config_dir, options);
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          args = [];
          if (options.watch) {
            args.push('-w');
          }
          if (set_options.bare) {
            args.push('-b');
          }
          if (set_options.join) {
            args.push('-j');
            args.push(set_options.join);
          }
          args.push('-o');
          if (set_options.output) {
            args.push(set_options.output);
          } else {
            args.push(this.config_dir);
          }
          args.push('-c');
          if (file_group.files) {
            args = args.concat(_.map(file_group.files, function(file) {
              return path.join(file_group.directory, file);
            }));
          } else {
            args.push(file_group.directory);
          }
          command_queue.push(new eb.command.Coffee(args, {
            cwd: file_group.directory,
            compress: set_options.compress,
            test: options.test
          }));
        }
        eb.utils.extractSetCommands(set_options, command_queue, this.config_dir);
        if (set_options.bundles) {
          command_queue.push(new eb.command.Bundle(set_options.bundles, {
            cwd: this.config_dir
          }));
        }
      }
      if (options.verbose) {
        command_queue.push({
          run: function(run_options, callback, queue) {
            console.log("build completed with " + (queue.errorCount()) + " error(s)");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.test = function(options, callback) {
      var args, command_queue, easy_bake_runner_used, file, file_group, file_groups, length_base, set, set_name, set_options, test_queue, _i, _j, _len, _len1, _ref1, _ref2,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      if (options.build || options.watch) {
        this.build(_.defaults({
          test: true,
          queue: command_queue
        }, options));
      }
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'tests'));
      if (options.verbose) {
        test_queue.push({
          run: function(run_options, callback, queue) {
            console.log("------------test " + (options.preview ? 'started (PREVIEW)' : 'started') + "------------");
            return typeof callback === "function" ? callback() : void 0;
          }
        });
      }
      _ref1 = this.config;
      for (set_name in _ref1) {
        set = _ref1[set_name];
        if (set_name.startsWith('_') || !set.hasOwnProperty('_test')) {
          continue;
        }
        set_options = eb.utils.extractSetOptions(set, '_test');
        file_groups = eb.utils.getOptionsFileGroups(set_options, this.config_dir, options);
        if (set_options.runner && !path.existsSync(set_options.runner)) {
          set_options.runner = "" + RUNNERS_ROOT + "/" + set_options.runner;
          easy_bake_runner_used = true;
        }
        for (_i = 0, _len = file_groups.length; _i < _len; _i++) {
          file_group = file_groups[_i];
          if (!file_group.files) {
            throw "missing files for test in set: " + set_name;
          }
          _ref2 = file_group.files;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            file = _ref2[_j];
            args = [];
            if (set_options.runner) {
              args.push(set_options.runner);
            }
            args.push(path.join(file_group.directory, file));
            if (set_options.args) {
              args = args.concat(set_options.args);
            }
            if (easy_bake_runner_used) {
              length_base = set_options.runner ? 2 : 1;
              if (args.length < (length_base + 1)) {
                args.push(TEST_DEFAULT_TIMEOUT);
              }
              if (args.length < (length_base + 2)) {
                args.push(true);
              }
            }
            test_queue.push(new eb.command.RunTest(set_options.command, args, {
              cwd: this.config_dir
            }));
          }
        }
        eb.utils.extractSetCommands(set, command_queue, this.config_dir);
      }
      if (!options.preview) {
        test_queue.push({
          run: function(run_options, callback, queue) {
            var command, total_error_count, _k, _len2, _ref3;
            if (!(options.preview || options.verbose)) {
              total_error_count = 0;
              console.log("\n-------------GROUP TEST RESULTS--------");
              _ref3 = test_queue.commands();
              for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                command = _ref3[_k];
                if (!(command instanceof eb.command.RunTest)) {
                  continue;
                }
                total_error_count += command.exitCode() ? 1 : 0;
                console.log("" + (command.exitCode() ? '✖' : '✔') + " " + (eb.utils.relativePath(command.fileName(), _this.config_dir)) + (command.exitCode() ? ' (exit code: ' + command.exitCode() + ')' : ''));
              }
              console.log("--------------------------------------");
              console.log(total_error_count ? "All tests ran with with " + total_error_count + " error(s)" : "All tests ran successfully!");
              console.log("--------------------------------------");
            }
            if (typeof callback === "function") {
              callback(0);
            }
            if (!options.watch && !options.no_exit) {
              return process.exit(queue.errorCount() > 0 ? 1 : 0);
            }
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.publishGit = function(options, callback) {
      var command_queue, test_options, test_queue,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'publish_git'));
      if (!options.quick) {
        test_options = _.defaults({
          queue: test_queue
        }, options);
        this.clean(test_options).postinstall(test_options).build(test_options).test(_.defaults({
          no_exit: true
        }, test_options));
      }
      test_queue.push({
        run: function(run_options, callback, queue) {
          var command;
          if (!(options.preview || options.verbose)) {
            if (queue.errorCount()) {
              console.log("publish_git aborted due to " + (queue.errorCount()) + " error(s)");
              if (typeof callback === "function") {
                callback(queue.errorCount());
              }
              return;
            }
          }
          command = new eb.command.PublishGit({
            cwd: _this.config_dir
          });
          return command.run(options, function(code) {
            if (!options.verbose) {
              console.log("publish_git completed with " + code + " error(s)");
            }
            return typeof callback === "function" ? callback(code) : void 0;
          });
        }
      });
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.publishNPM = function(options, callback) {
      var command_queue, test_options, test_queue,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'publish_npm'));
      if (!options.quick) {
        test_options = _.defaults({
          queue: test_queue
        }, options);
        this.clean(test_options).postinstall(test_options).build(test_options).test(_.defaults({
          no_exit: true
        }, test_options));
      }
      test_queue.push({
        run: function(run_options, callback, queue) {
          var command, package_desc, package_desc_path, package_path;
          if (!(options.preview || options.verbose)) {
            if (queue.errorCount()) {
              console.log("publish_npm aborted due to " + (queue.errorCount()) + " error(s)");
              if (typeof callback === "function") {
                callback(queue.errorCount());
              }
              return;
            }
          }
          package_path = path.join(_this.config_dir, 'packages', 'npm');
          if (!path.existsSync(package_path)) {
            package_path = _this.config_dir;
          }
          package_desc_path = path.join(package_path, 'package.json');
          if (!path.existsSync(package_desc_path)) {
            console.log("no package.json found for publish_npm: " + (package_desc_path.replace(_this.config_dir, '')));
            if (typeof callback === "function") {
              callback(1);
            }
            return;
          }
          package_desc = require(package_desc_path);
          if (package_desc.name.startsWith('_')) {
            console.log("skipping publish_npm for: " + package_desc_path + " (name starts with '_')");
            if (typeof callback === "function") {
              callback(1);
            }
            return;
          }
          if (!path.existsSync(path.join(package_path, package_desc.main))) {
            console.log("skipping publish_npm for: " + package_desc_path + " (main file missing...do you need to build it?)");
            if (typeof callback === "function") {
              callback(1);
            }
            return;
          }
          command = new eb.command.PublishNPM({
            force: options.force,
            cwd: package_path
          });
          return command.run(options, function(code) {
            if (!options.verbose) {
              console.log("publish_npm completed with " + code + " error(s)");
            }
            return typeof callback === "function" ? callback(code) : void 0;
          });
        }
      });
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.publishNuGet = function(options, callback) {
      var command_queue, test_options, test_queue,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      test_queue = new eb.command.Queue();
      command_queue.push(new eb.command.RunQueue(test_queue, 'publish_nuget'));
      if (!options.quick) {
        test_options = _.defaults({
          queue: test_queue
        }, options);
        this.clean(test_options).postinstall(test_options).build(test_options).test(_.defaults({
          no_exit: true
        }, test_options));
      }
      test_queue.push({
        run: function(run_options, callback, queue) {
          var command, command_options, file, files, package_desc, package_desc_path, package_path, pathed_filename, _i, _len;
          if (!(options.preview || options.verbose)) {
            if (queue.errorCount()) {
              console.log("publish_nuget aborted due to " + (queue.errorCount()) + " error(s)");
              if (typeof callback === "function") {
                callback(queue.errorCount());
              }
              return;
            }
          }
          package_path = path.join(_this.config_dir, 'packages', 'nuget');
          if (!path.existsSync(package_path)) {
            if (typeof callback === "function") {
              callback(0);
            }
            return;
          }
          package_desc_path = path.join(package_path, 'package.nuspec');
          if (!path.existsSync(package_desc_path)) {
            console.log("no package.nuspec found for publishNuGet: " + (package_desc_path.replace(_this.config_dir, '')));
            if (typeof callback === "function") {
              callback(1);
            }
            return;
          }
          package_desc = et.parse(fs.readFileSync(package_desc_path, 'utf8').toString());
          command_options = {};
          command_options.version = package_desc.findtext('./metadata/version');
          command_options.name = package_desc.findtext('./metadata/id');
          if (!command_options.version) {
            console.log("package.nuspec missing metadata.version: " + (package_desc_path.replace(_this.config_dir, '')));
            if (typeof callback === "function") {
              callback(1);
            }
            return;
          }
          if (!command_options.name) {
            console.log("package.nuspec missing metadata.name: " + (package_desc_path.replace(_this.config_dir, '')));
            if (typeof callback === "function") {
              callback(1);
            }
            return;
          }
          if (command_options.name.startsWith('_')) {
            console.log("skipping publish_npm for: " + package_desc_path + " (name starts with '_')");
            if (typeof callback === "function") {
              callback(1);
            }
            return;
          }
          files = package_desc.findall('./files/file');
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            pathed_filename = path.join(package_path, file.get('src'));
            pathed_filename = pathed_filename.replace(/\\/g, '\/');
            if (!path.existsSync(pathed_filename)) {
              console.log("skipping publish_npm for: " + package_desc_path + " (main file missing...do you need to build it?)");
              if (typeof callback === "function") {
                callback(1);
              }
              return;
            }
          }
          command_options.force = options.force;
          command_options.cwd = package_path;
          command = new eb.command.PublishNuGet(command_options);
          return command.run(options, function(code) {
            if (!options.verbose) {
              console.log("publish_nuget completed with " + code + " error(s)");
            }
            return typeof callback === "function" ? callback(code) : void 0;
          });
        }
      });
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    Oven.prototype.publishAll = function(options, callback) {
      var command_queue, publish_options, quick, test_options, test_queue,
        _this = this;
      if (options == null) {
        options = {};
      }
      command_queue = options.queue ? options.queue : new eb.command.Queue();
      quick = options.quick;
      publish_options = _.clone(options);
      delete publish_options['quick'];
      publish_options.queue = new eb.command.Queue();
      if (quick) {
        command_queue.push(new eb.command.RunQueue(publish_options.queue, 'publish_all'));
        this.publishNPM(publish_options).publishGit(publish_options).publishNuGet(publish_options);
      } else {
        test_queue = new eb.command.Queue();
        command_queue.push(new eb.command.RunQueue(test_queue, 'publish_all'));
        test_queue = new eb.command.Queue();
        test_options = _.defaults({
          queue: test_queue
        }, options);
        this.clean(test_options).postinstall(test_options).build(test_options).test(_.defaults({
          no_exit: true
        }, test_options));
        test_queue.push({
          run: function(run_options, callback, queue) {
            if (!(options.preview || options.verbose)) {
              if (queue.errorCount()) {
                console.log("publish_all aborted due to " + (queue.errorCount()) + " error(s)");
                if (typeof callback === "function") {
                  callback(queue.errorCount());
                }
                return;
              }
            }
            _this.publishNPM(publish_options).publishGit(publish_options).publishNuGet(publish_options);
            return publish_options.queue.run(options, callback);
          }
        });
      }
      if (!options.queue) {
        command_queue.run(options, callback);
      }
      return this;
    };

    return Oven;

  })();

}).call(this);
